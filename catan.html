<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Catan 6P Settlement Optimizer</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
<style>
@keyframes fadeInUp {
  from { opacity: 0; transform: translateY(20px); }
  to { opacity: 1; transform: translateY(0); }
}
@keyframes shimmer {
  0% { background-position: -200% 0; }
  100% { background-position: 200% 0; }
}
@keyframes subtlePulse {
  0%, 100% { opacity: 0.6; }
  50% { opacity: 1; }
}

* { margin: 0; padding: 0; box-sizing: border-box; }

body {
  background: #0a0e1a;
  color: #e2e8f0;
  font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
  display: flex;
  flex-direction: column;
  align-items: center;
  min-height: 100vh;
  padding: 20px 12px 40px;
  animation: fadeInUp 0.6s ease-out;
}

/* --- Header --- */
.header {
  text-align: center;
  margin-bottom: 16px;
  animation: fadeInUp 0.5s ease-out;
}
h1 {
  font-size: 1.6em;
  font-weight: 800;
  letter-spacing: -0.02em;
  background: linear-gradient(135deg, #e6a817, #f0d060);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
}
.subtitle {
  color: #64748b;
  font-size: 0.85em;
  font-weight: 400;
  margin-top: 4px;
}

/* --- Glass Card Mixin --- */
.glass {
  background: rgba(255, 255, 255, 0.04);
  backdrop-filter: blur(16px);
  -webkit-backdrop-filter: blur(16px);
  border: 1px solid rgba(255, 255, 255, 0.07);
  border-radius: 14px;
}

/* --- Controls Bar --- */
.controls {
  display: flex;
  gap: 8px;
  margin-bottom: 16px;
  flex-wrap: wrap;
  justify-content: center;
  align-items: center;
  padding: 12px 16px;
  max-width: 820px;
  width: 100%;
  animation: fadeInUp 0.6s ease-out 0.1s both;
}

button {
  background: linear-gradient(135deg, #e6a817, #d49b10);
  color: #0a0e1a;
  border: none;
  padding: 10px 18px;
  border-radius: 10px;
  cursor: pointer;
  font-weight: 600;
  font-size: 0.85em;
  font-family: 'Inter', sans-serif;
  touch-action: manipulation;
  -webkit-tap-highlight-color: transparent;
  transition: all 0.2s ease;
  box-shadow: 0 2px 8px rgba(230, 168, 23, 0.2);
}
button:hover {
  transform: translateY(-1px) scale(1.02);
  box-shadow: 0 4px 16px rgba(230, 168, 23, 0.35);
  background: linear-gradient(135deg, #f0c040, #e6a817);
}
button:active {
  transform: scale(0.97);
  box-shadow: 0 1px 4px rgba(230, 168, 23, 0.2);
}
button.secondary {
  background: rgba(255, 255, 255, 0.06);
  color: #94a3b8;
  box-shadow: none;
  border: 1px solid rgba(255, 255, 255, 0.08);
}
button.secondary:hover {
  background: rgba(255, 255, 255, 0.1);
  color: #e2e8f0;
  box-shadow: 0 2px 8px rgba(0,0,0,0.2);
}

select {
  background: rgba(255, 255, 255, 0.06);
  color: #e2e8f0;
  border: 1px solid rgba(255, 255, 255, 0.1);
  padding: 9px 12px;
  border-radius: 10px;
  font-size: 0.85em;
  font-family: 'Inter', sans-serif;
  cursor: pointer;
  transition: all 0.2s ease;
  -webkit-appearance: none;
  appearance: none;
  background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 24 24' fill='none' stroke='%2394a3b8' stroke-width='2'%3E%3Cpath d='M6 9l6 6 6-6'/%3E%3C/svg%3E");
  background-repeat: no-repeat;
  background-position: right 8px center;
  padding-right: 28px;
}
select:hover { border-color: rgba(230, 168, 23, 0.3); }
select:focus { outline: none; border-color: rgba(230, 168, 23, 0.5); box-shadow: 0 0 0 2px rgba(230, 168, 23, 0.15); }

label {
  display: flex;
  align-items: center;
  gap: 6px;
  font-size: 0.82em;
  color: #94a3b8;
  font-weight: 500;
}

/* --- Canvas --- */
.canvas-wrap {
  position: relative;
  display: inline-block;
  width: 100%;
  max-width: 820px;
  animation: fadeInUp 0.6s ease-out 0.2s both;
}
canvas {
  border-radius: 16px;
  cursor: pointer;
  width: 100%;
  height: auto;
  display: block;
  border: 1px solid rgba(255, 255, 255, 0.06);
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4), 0 0 0 1px rgba(255,255,255,0.03);
}

/* --- Tooltip --- */
#tooltip {
  position: absolute;
  background: rgba(15, 20, 35, 0.92);
  backdrop-filter: blur(12px);
  -webkit-backdrop-filter: blur(12px);
  color: #e2e8f0;
  padding: 10px 14px;
  border-radius: 10px;
  font-size: 0.8em;
  pointer-events: none;
  display: none;
  z-index: 10;
  line-height: 1.5;
  border: 1px solid rgba(255, 255, 255, 0.1);
  box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
  transition: opacity 0.15s ease;
  font-family: 'Inter', sans-serif;
}

/* --- Legend --- */
.legend {
  display: flex;
  gap: 8px;
  margin-top: 14px;
  flex-wrap: wrap;
  justify-content: center;
  animation: fadeInUp 0.6s ease-out 0.3s both;
}
.legend-item {
  display: flex;
  align-items: center;
  gap: 6px;
  font-size: 0.75em;
  font-weight: 500;
  color: #94a3b8;
  padding: 5px 12px 5px 8px;
  border-radius: 20px;
  background: rgba(255, 255, 255, 0.04);
  border: 1px solid rgba(255, 255, 255, 0.06);
  transition: background 0.2s ease;
}
.legend-item:hover { background: rgba(255, 255, 255, 0.07); }
.legend-dot {
  width: 10px;
  height: 10px;
  border-radius: 50%;
  flex-shrink: 0;
}

/* --- Top List --- */
.top-list {
  margin-top: 14px;
  padding: 16px 20px;
  max-width: 820px;
  width: 100%;
  animation: fadeInUp 0.6s ease-out 0.35s both;
}
.top-list h3 {
  font-size: 0.95em;
  font-weight: 700;
  margin-bottom: 12px;
  background: linear-gradient(135deg, #e6a817, #f0d060);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
}
.top-list ol {
  padding-left: 0;
  list-style: none;
  counter-reset: top-counter;
}
.top-list li {
  counter-increment: top-counter;
  margin-bottom: 6px;
  color: #cbd5e1;
  line-height: 1.5;
  padding: 8px 12px;
  border-radius: 10px;
  background: rgba(255, 255, 255, 0.02);
  border: 1px solid rgba(255, 255, 255, 0.04);
  font-size: 0.82em;
  transition: background 0.2s ease;
  display: flex;
  align-items: baseline;
  gap: 8px;
}
.top-list li:hover { background: rgba(255, 255, 255, 0.05); }
.top-list li::before {
  content: counter(top-counter);
  font-weight: 700;
  color: #475569;
  font-size: 0.85em;
  min-width: 18px;
}
.top-list li span.dots {
  color: #e6a817;
  font-weight: 700;
}
.top-list li span.res {
  color: #64748b;
  font-size: 0.9em;
}
.top-list p { color: #475569; font-size: 0.85em; }

/* --- Info Panel --- */
.info-toggle {
  margin-top: 14px;
  max-width: 820px;
  width: 100%;
  animation: fadeInUp 0.6s ease-out 0.4s both;
}
.info-toggle summary {
  cursor: pointer;
  font-size: 0.82em;
  font-weight: 600;
  color: #64748b;
  padding: 10px 16px;
  border-radius: 12px;
  background: rgba(255, 255, 255, 0.03);
  border: 1px solid rgba(255, 255, 255, 0.05);
  list-style: none;
  display: flex;
  align-items: center;
  gap: 6px;
  transition: all 0.2s ease;
  user-select: none;
}
.info-toggle summary:hover { background: rgba(255, 255, 255, 0.06); color: #94a3b8; }
.info-toggle summary::-webkit-details-marker { display: none; }
.info-toggle summary::before { content: '‚ñ∏'; transition: transform 0.2s ease; display: inline-block; }
.info-toggle[open] summary::before { transform: rotate(90deg); }
.info-content {
  padding: 14px 16px;
  font-size: 0.8em;
  line-height: 1.6;
  color: #64748b;
}
.info-content b { color: #94a3b8; }

/* --- Mobile --- */
@media (max-width: 500px) {
  body { padding: 12px 8px 32px; }
  h1 { font-size: 1.3em; }
  .controls { padding: 10px 12px; gap: 6px; }
  button { padding: 9px 14px; font-size: 0.82em; }
  select { padding: 8px 10px; font-size: 0.82em; }
  .legend { gap: 6px; }
  .legend-item { font-size: 0.7em; padding: 4px 10px 4px 6px; }
  .top-list { padding: 12px 14px; }
  .top-list li { padding: 6px 10px; font-size: 0.78em; }
}
</style>
</head>
<body>

<div class="header">
  <h1>üè† Catan 6P Settlement Optimizer</h1>
  <p class="subtitle">Click tiles to assign numbers ¬∑ see the best settlement spots</p>
</div>

<div class="controls glass">
  <label>Assign: <select id="numberSelect">
    <option value="0">Desert</option>
    <option value="2">2</option><option value="3">3</option><option value="4">4</option><option value="5">5</option>
    <option value="6">6</option><option value="8">8</option><option value="9">9</option>
    <option value="10">10</option><option value="11">11</option><option value="12">12</option>
  </select></label>
  <button id="randomBtn">üé≤ Random Board</button>
  <button id="scanBtn">üì∑ Scan Board</button>
  <button id="clearBtn" class="secondary">Clear</button>
  <label>Show top: <select id="topN"><option value="5">5</option><option value="10" selected>10</option><option value="15">15</option><option value="20">20</option></select></label>
  <input type="file" id="photoInput" accept="image/*" capture="environment" style="display:none">
</div>

<div class="canvas-wrap">
  <canvas id="board" width="820" height="760"></canvas>
  <div id="tooltip"></div>
</div>

<div class="legend">
  <div class="legend-item"><div class="legend-dot" style="background:#00ff88;box-shadow:0 0 6px #00ff8866;"></div> Best</div>
  <div class="legend-item"><div class="legend-dot" style="background:#ffdd00;box-shadow:0 0 6px #ffdd0066;"></div> Great</div>
  <div class="legend-item"><div class="legend-dot" style="background:#ff8800;box-shadow:0 0 6px #ff880066;"></div> Good</div>
  <div class="legend-item"><div class="legend-dot" style="background:#ff3355;box-shadow:0 0 6px #ff335566;"></div> Weak</div>
  <div class="legend-item"><div class="legend-dot" style="background:#475569;"></div> No value</div>
</div>

<div class="top-list glass" id="topList"></div>

<details class="info-toggle">
  <summary>How it works</summary>
  <div class="info-content">
    <b>Each number token</b> has a probability of being rolled (dots on the token).
    A settlement vertex touches up to 3 tiles. The optimizer sums the probabilities of all adjacent tiles
    for every vertex and ranks them. Resource diversity is shown but not weighted ‚Äî you decide what matters.
    Click a tile to assign a number, hit Random for a valid 6-player layout, or <b>üì∑ Scan Board</b> to
    take a photo of your real Catan board and auto-populate everything with AI vision (requires OpenAI API key, stored locally).
  </div>
</details>

<script>
const ROWS = [3,4,5,6,5,4,3];
const TOTAL_TILES = 30;

const RESOURCE_COLORS = {
  brick: '#c0392b', ore: '#7f8c8d', wood: '#27ae60', wheat: '#f1c40f', sheep: '#2ecc71', desert: '#c2b280'
};
const RESOURCE_NAMES = ['brick','ore','wood','wheat','sheep'];
const DOTS = {0:0, 2:1, 3:2, 4:3, 5:4, 6:5, 8:5, 9:4, 10:3, 11:2, 12:1};

function generateRandomNumbers() {
  const nums = [0,0,2,2,3,3,3,4,4,4,5,5,5,6,6,6,6,8,8,8,8,9,9,9,10,10,10,11,11,11,12,12];
  for (let i = nums.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [nums[i], nums[j]] = [nums[j], nums[i]];
  }
  return nums;
}

function generateRandomResources() {
  const res = [
    ...Array(2).fill('desert'),
    ...Array(5).fill('brick'),
    ...Array(5).fill('ore'),
    ...Array(6).fill('wood'),
    ...Array(6).fill('wheat'),
    ...Array(6).fill('sheep')
  ];
  for (let i = res.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [res[i], res[j]] = [res[j], res[i]];
  }
  return res;
}

let tiles = [];
let vertices = [];

const canvas = document.getElementById('board');
const ctx = canvas.getContext('2d');
const tooltip = document.getElementById('tooltip');

const HEX_R = 46;
const HEX_H = HEX_R * Math.sqrt(3);
const CX = canvas.width / 2;
const CY = canvas.height / 2;

function hexCorner(cx, cy, r, i) {
  const angle = Math.PI / 180 * (60 * i - 30);
  return { x: cx + r * Math.cos(angle), y: cy + r * Math.sin(angle) };
}

function buildBoard() {
  tiles = [];
  const vSpacing = 1.5 * HEX_R;
  const hSpacing = Math.sqrt(3) * HEX_R;
  const totalHeight = (ROWS.length - 1) * vSpacing;
  const topY = CY - totalHeight / 2;

  let tileIdx = 0;
  for (let r = 0; r < ROWS.length; r++) {
    const count = ROWS[r];
    const y = topY + r * vSpacing;
    const rowWidth = (count - 1) * hSpacing;
    const startX = CX - rowWidth / 2;
    for (let c = 0; c < count; c++) {
      tiles.push({
        cx: startX + c * hSpacing,
        cy: y,
        number: 0,
        resource: 'desert',
        row: r, col: c, idx: tileIdx++
      });
    }
  }
  buildVertices();
}

function buildVertices() {
  vertices = [];
  const vMap = new Map();
  const SNAP = 3;
  function snapKey(x, y) {
    const sx = Math.round(x / SNAP) * SNAP;
    const sy = Math.round(y / SNAP) * SNAP;
    return `${sx},${sy}`;
  }
  for (let t = 0; t < tiles.length; t++) {
    const tile = tiles[t];
    for (let i = 0; i < 6; i++) {
      const corner = hexCorner(tile.cx, tile.cy, HEX_R, i);
      const key = snapKey(corner.x, corner.y);
      if (!vMap.has(key)) {
        const vIdx = vertices.length;
        vertices.push({ x: corner.x, y: corner.y, adjacentTiles: [t], key });
        vMap.set(key, vIdx);
      } else {
        const vIdx = vMap.get(key);
        if (!vertices[vIdx].adjacentTiles.includes(t)) {
          vertices[vIdx].adjacentTiles.push(t);
        }
      }
    }
  }
}

function computeVertexValues() {
  for (const v of vertices) {
    let totalDots = 0;
    const resources = new Set();
    for (const tIdx of v.adjacentTiles) {
      const t = tiles[tIdx];
      totalDots += DOTS[t.number] || 0;
      if (t.resource !== 'desert' && t.number > 0) resources.add(t.resource);
    }
    v.dots = totalDots;
    v.resources = resources;
  }
}

function randomizeBoard() {
  const numbers = generateRandomNumbers();
  const resources = generateRandomResources();
  for (let i = 0; i < tiles.length; i++) {
    tiles[i].resource = resources[i];
    tiles[i].number = 0;
  }
  const numberedTokens = numbers.filter(n => n > 0);
  let ni = 0;
  for (let i = 0; i < tiles.length; i++) {
    if (tiles[i].resource === 'desert') {
      tiles[i].number = 0;
    } else {
      tiles[i].number = numberedTokens[ni++] || 0;
    }
  }
}

function drawBoard() {
  const dpr = window.devicePixelRatio || 1;
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // Radial gradient background
  const grad = ctx.createRadialGradient(CX, CY, 0, CX, CY, canvas.width * 0.55);
  grad.addColorStop(0, '#0f2847');
  grad.addColorStop(0.6, '#0a1a35');
  grad.addColorStop(1, '#060d1f');
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  // Subtle grid dots for texture
  ctx.fillStyle = 'rgba(255,255,255,0.015)';
  for (let x = 0; x < canvas.width; x += 20) {
    for (let y = 0; y < canvas.height; y += 20) {
      ctx.fillRect(x, y, 1, 1);
    }
  }

  for (const tile of tiles) drawHex(tile);

  computeVertexValues();
  const maxDots = Math.max(...vertices.map(v => v.dots), 1);
  const sorted = [...vertices].filter(v => v.dots > 0).sort((a, b) => b.dots - a.dots);
  const topN = parseInt(document.getElementById('topN').value);
  const topSet = new Set(sorted.slice(0, topN));

  for (const v of vertices) {
    if (v.dots === 0) continue;
    const ratio = v.dots / maxDots;
    const rank = sorted.indexOf(v);
    let color, radius, glowColor;

    if (topSet.has(v) && rank < Math.ceil(topN * 0.3)) {
      color = '#00ff88'; radius = 11; glowColor = 'rgba(0,255,136,0.5)';
    } else if (topSet.has(v) && rank < Math.ceil(topN * 0.6)) {
      color = '#ffdd00'; radius = 10; glowColor = 'rgba(255,221,0,0.4)';
    } else if (topSet.has(v)) {
      color = '#ff8800'; radius = 9; glowColor = 'rgba(255,136,0,0.35)';
    } else {
      color = `rgba(255,255,255,${0.12 + ratio * 0.3})`;
      radius = 4 + ratio * 3;
      glowColor = null;
    }

    // Glow for top spots
    if (glowColor) {
      ctx.save();
      ctx.shadowColor = glowColor;
      ctx.shadowBlur = 14;
      ctx.beginPath();
      ctx.arc(v.x, v.y, radius, 0, Math.PI * 2);
      ctx.fillStyle = color;
      ctx.fill();
      ctx.restore();

      // White ring
      ctx.beginPath();
      ctx.arc(v.x, v.y, radius, 0, Math.PI * 2);
      ctx.strokeStyle = 'rgba(255,255,255,0.6)';
      ctx.lineWidth = 1.5;
      ctx.stroke();

      // Dots number
      ctx.fillStyle = '#000';
      ctx.font = 'bold 9px Inter, sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(v.dots, v.x, v.y);
    } else {
      ctx.beginPath();
      ctx.arc(v.x, v.y, radius, 0, Math.PI * 2);
      ctx.fillStyle = color;
      ctx.fill();
    }
  }

  updateTopList(sorted, topN);
}

function drawHex(tile) {
  const corners = [];
  for (let i = 0; i < 6; i++) corners.push(hexCorner(tile.cx, tile.cy, HEX_R - 2, i));

  // Hex fill
  ctx.beginPath();
  ctx.moveTo(corners[0].x, corners[0].y);
  for (let i = 1; i < 6; i++) ctx.lineTo(corners[i].x, corners[i].y);
  ctx.closePath();

  const baseColor = RESOURCE_COLORS[tile.resource] || '#555';
  ctx.fillStyle = baseColor;
  ctx.fill();

  // Subtle inner gradient for depth
  const innerGrad = ctx.createRadialGradient(tile.cx - 8, tile.cy - 8, 0, tile.cx, tile.cy, HEX_R);
  innerGrad.addColorStop(0, 'rgba(255,255,255,0.1)');
  innerGrad.addColorStop(1, 'rgba(0,0,0,0.15)');
  ctx.fillStyle = innerGrad;
  ctx.fill();

  // Border
  ctx.strokeStyle = 'rgba(0,0,0,0.4)';
  ctx.lineWidth = 2;
  ctx.stroke();
  // Lighter inner border
  const innerCorners = [];
  for (let i = 0; i < 6; i++) innerCorners.push(hexCorner(tile.cx, tile.cy, HEX_R - 4, i));
  ctx.beginPath();
  ctx.moveTo(innerCorners[0].x, innerCorners[0].y);
  for (let i = 1; i < 6; i++) ctx.lineTo(innerCorners[i].x, innerCorners[i].y);
  ctx.closePath();
  ctx.strokeStyle = 'rgba(255,255,255,0.08)';
  ctx.lineWidth = 1;
  ctx.stroke();

  // Number token
  if (tile.number > 0) {
    const isHot = tile.number === 6 || tile.number === 8;

    // Token shadow
    ctx.save();
    ctx.shadowColor = 'rgba(0,0,0,0.4)';
    ctx.shadowBlur = 6;
    ctx.shadowOffsetY = 2;
    ctx.beginPath();
    ctx.arc(tile.cx, tile.cy, 17, 0, Math.PI * 2);
    ctx.fillStyle = '#f5f0dc';
    ctx.fill();
    ctx.restore();

    // Token border
    ctx.beginPath();
    ctx.arc(tile.cx, tile.cy, 17, 0, Math.PI * 2);
    ctx.strokeStyle = isHot ? 'rgba(204,0,0,0.3)' : 'rgba(0,0,0,0.15)';
    ctx.lineWidth = 1.5;
    ctx.stroke();

    ctx.fillStyle = isHot ? '#cc0000' : '#1a1a2e';
    ctx.font = isHot ? 'bold 15px Inter, sans-serif' : '600 14px Inter, sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(tile.number, tile.cx, tile.cy - 1);

    // Dots
    const d = DOTS[tile.number];
    const dotY = tile.cy + 10;
    const dotStart = tile.cx - (d - 1) * 3;
    ctx.fillStyle = isHot ? '#cc0000' : '#888';
    for (let i = 0; i < d; i++) {
      ctx.beginPath();
      ctx.arc(dotStart + i * 6, dotY, 1.8, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  // Resource label
  ctx.fillStyle = 'rgba(255,255,255,0.65)';
  ctx.font = '500 8.5px Inter, sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText(tile.resource, tile.cx, tile.cy + (tile.number > 0 ? 24 : 5));
}

function updateTopList(sorted, topN) {
  const el = document.getElementById('topList');
  const shown = sorted.slice(0, topN);
  if (shown.length === 0) {
    el.innerHTML = '<h3>Top Settlement Spots</h3><p>Assign numbers to tiles first (click tiles or hit Random)</p>';
    return;
  }
  let html = `<h3>Top ${topN} Settlement Spots</h3><ol>`;
  for (const v of shown) {
    const resList = v.adjacentTiles.map(i => {
      const t = tiles[i];
      return t.number > 0 ? `${t.resource}(${t.number})` : null;
    }).filter(Boolean).join(', ');
    html += `<li><span class="dots">${v.dots} pips</span> <span class="res">‚Äî ${resList || 'none'}</span></li>`;
  }
  html += '</ol>';
  el.innerHTML = html;
}

// Click handling
canvas.addEventListener('click', (e) => {
  const rect = canvas.getBoundingClientRect();
  const mx = (e.clientX - rect.left) * (canvas.width / rect.width);
  const my = (e.clientY - rect.top) * (canvas.height / rect.height);
  let closest = null, minDist = Infinity;
  for (const tile of tiles) {
    const d = Math.hypot(mx - tile.cx, my - tile.cy);
    if (d < HEX_R && d < minDist) { closest = tile; minDist = d; }
  }
  if (closest) {
    const num = parseInt(document.getElementById('numberSelect').value);
    closest.number = num;
    if (num === 0) closest.resource = 'desert';
    else if (closest.resource === 'desert') {
      closest.resource = RESOURCE_NAMES[Math.floor(Math.random() * RESOURCE_NAMES.length)];
    }
    drawBoard();
  }
});

// Tooltip
canvas.addEventListener('mousemove', (e) => {
  const rect = canvas.getBoundingClientRect();
  const mx = (e.clientX - rect.left) * (canvas.width / rect.width);
  const my = (e.clientY - rect.top) * (canvas.height / rect.height);
  let closest = null, minDist = Infinity;
  for (const v of vertices) {
    if (v.dots === 0) continue;
    const d = Math.hypot(mx - v.x, my - v.y);
    if (d < 15 && d < minDist) { closest = v; minDist = d; }
  }
  if (closest) {
    const lines = [`<b>${closest.dots} pips</b> (${(closest.dots / 36 * 100).toFixed(1)}% per roll)`];
    for (const tIdx of closest.adjacentTiles) {
      const t = tiles[tIdx];
      if (t.number > 0) lines.push(`${t.resource} ${t.number} (${DOTS[t.number]} pips)`);
    }
    lines.push(`Diversity: ${closest.resources.size} resource${closest.resources.size !== 1 ? 's' : ''}`);
    tooltip.innerHTML = lines.join('<br>');
    tooltip.style.display = 'block';
    tooltip.style.left = (e.clientX - rect.left + 15) + 'px';
    tooltip.style.top = (e.clientY - rect.top - 10) + 'px';
  } else {
    tooltip.style.display = 'none';
  }
});
canvas.addEventListener('mouseleave', () => { tooltip.style.display = 'none'; });

document.getElementById('randomBtn').addEventListener('click', () => { randomizeBoard(); drawBoard(); });
document.getElementById('clearBtn').addEventListener('click', () => {
  for (const t of tiles) { t.number = 0; t.resource = 'desert'; }
  drawBoard();
});
document.getElementById('topN').addEventListener('change', drawBoard);

// --- Photo Scan Feature ---
const scanBtn = document.getElementById('scanBtn');
const photoInput = document.getElementById('photoInput');

function getApiKey() {
  let key = localStorage.getItem('openai_api_key');
  if (key) return key;
  key = prompt('Enter your OpenAI API key to use board scanning.\nIt\'s stored locally in your browser only.\n\nGet one at platform.openai.com/api-keys');
  if (key && key.startsWith('sk-')) {
    localStorage.setItem('openai_api_key', key);
    return key;
  }
  return null;
}

scanBtn.addEventListener('click', () => {
  const key = getApiKey();
  if (!key) return;
  photoInput.click();
});

photoInput.addEventListener('change', async (e) => {
  const file = e.target.files[0];
  if (!file) return;
  const key = localStorage.getItem('openai_api_key');
  if (!key) return;

  scanBtn.textContent = '‚è≥ Analyzing...';
  scanBtn.disabled = true;

  try {
    const base64 = await new Promise((resolve) => {
      const reader = new FileReader();
      reader.onload = () => resolve(reader.result.split(',')[1]);
      reader.readAsDataURL(file);
    });

    const response = await fetch('https://api.openai.com/v1/chat/completions', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${key}` },
      body: JSON.stringify({
        model: 'gpt-4o',
        max_tokens: 1500,
        messages: [{
          role: 'user',
          content: [
            { type: 'text', text: `Analyze this photo of a Catan board. The board has hex tiles arranged in rows of [3,4,5,6,5,4,3] (30 tiles total for 6-player, or [3,4,5,4,3] = 19 tiles for standard).

For each tile, identify:
1. The resource type: brick (red/brown hills), ore (grey mountains), wood (dark green forest), wheat (yellow fields), sheep (light green pastures), or desert (tan/sandy, no number)
2. The number token on it (2-12, or 0 for desert)

Return ONLY a JSON array of objects, one per tile, in row-by-row order (top row left-to-right, then next row, etc.):
[{"resource":"wheat","number":5},{"resource":"ore","number":8},...]

If you can't identify a tile clearly, use your best guess. Desert tiles have number 0.` },
            { type: 'image_url', image_url: { url: `data:image/jpeg;base64,${base64}` } }
          ]
        }]
      })
    });

    const data = await response.json();
    if (data.error) {
      if (data.error.code === 'invalid_api_key') {
        localStorage.removeItem('openai_api_key');
        alert('Invalid API key. It has been cleared ‚Äî try again.');
      } else {
        alert('API error: ' + data.error.message);
      }
      return;
    }

    const content = data.choices[0].message.content;
    const jsonMatch = content.match(/\[[\s\S]*\]/);
    if (!jsonMatch) {
      alert('Could not parse board from image. Try a clearer photo.');
      return;
    }

    const parsed = JSON.parse(jsonMatch[0]);
    if (parsed.length === 19) {
      ROWS.length = 0;
      ROWS.push(3, 4, 5, 4, 3);
      buildBoard();
    } else if (parsed.length >= 28 && parsed.length <= 30) {
      ROWS.length = 0;
      ROWS.push(3, 4, 5, 6, 5, 4, 3);
      buildBoard();
    }

    const count = Math.min(parsed.length, tiles.length);
    for (let i = 0; i < count; i++) {
      const p = parsed[i];
      tiles[i].resource = p.resource || 'desert';
      tiles[i].number = parseInt(p.number) || 0;
      if (tiles[i].number === 0) tiles[i].resource = 'desert';
    }

    drawBoard();
    alert(`‚úÖ Board scanned! ${count} tiles detected.`);
  } catch (err) {
    console.error(err);
    alert('Failed to analyze image: ' + err.message);
  } finally {
    scanBtn.textContent = 'üì∑ Scan Board';
    scanBtn.disabled = false;
    photoInput.value = '';
  }
});

// Init
buildBoard();
drawBoard();
</script>
</body>
</html>
