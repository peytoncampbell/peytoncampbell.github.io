<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Catan Settlement Optimizer</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
<style>
@keyframes fadeInUp {
  from { opacity: 0; transform: translateY(20px); }
  to { opacity: 1; transform: translateY(0); }
}
@keyframes shimmer {
  0% { background-position: -200% 0; }
  100% { background-position: 200% 0; }
}
@keyframes subtlePulse {
  0%, 100% { opacity: 0.6; }
  50% { opacity: 1; }
}

* { margin: 0; padding: 0; box-sizing: border-box; }

body {
  background: #0a0e1a;
  color: #e2e8f0;
  font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
  display: flex;
  flex-direction: column;
  align-items: center;
  min-height: 100vh;
  padding: 20px 12px 40px;
  animation: fadeInUp 0.6s ease-out;
}

/* --- Header --- */
.header {
  text-align: center;
  margin-bottom: 16px;
  animation: fadeInUp 0.5s ease-out;
}
h1 {
  font-size: 1.6em;
  font-weight: 800;
  letter-spacing: -0.02em;
  background: linear-gradient(135deg, #e6a817, #f0d060);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
}
.subtitle {
  color: #64748b;
  font-size: 0.85em;
  font-weight: 400;
  margin-top: 4px;
}

/* --- Glass Card Mixin --- */
.glass {
  background: rgba(255, 255, 255, 0.04);
  backdrop-filter: blur(16px);
  -webkit-backdrop-filter: blur(16px);
  border: 1px solid rgba(255, 255, 255, 0.07);
  border-radius: 14px;
}

/* --- Controls Bar --- */
.controls {
  display: flex;
  gap: 8px;
  margin-bottom: 16px;
  flex-wrap: wrap;
  justify-content: center;
  align-items: center;
  padding: 12px 16px;
  max-width: 920px;
  width: 100%;
  animation: fadeInUp 0.6s ease-out 0.1s both;
}

button {
  background: linear-gradient(135deg, #e6a817, #d49b10);
  color: #0a0e1a;
  border: none;
  padding: 10px 18px;
  border-radius: 10px;
  cursor: pointer;
  font-weight: 600;
  font-size: 0.85em;
  font-family: 'Inter', sans-serif;
  touch-action: manipulation;
  -webkit-tap-highlight-color: transparent;
  transition: all 0.2s ease;
  box-shadow: 0 2px 8px rgba(230, 168, 23, 0.2);
}
button:hover {
  transform: translateY(-1px) scale(1.02);
  box-shadow: 0 4px 16px rgba(230, 168, 23, 0.35);
  background: linear-gradient(135deg, #f0c040, #e6a817);
}
button:active {
  transform: scale(0.97);
  box-shadow: 0 1px 4px rgba(230, 168, 23, 0.2);
}
button.secondary {
  background: rgba(255, 255, 255, 0.06);
  color: #94a3b8;
  box-shadow: none;
  border: 1px solid rgba(255, 255, 255, 0.08);
}
button.secondary:hover {
  background: rgba(255, 255, 255, 0.1);
  color: #e2e8f0;
  box-shadow: 0 2px 8px rgba(0,0,0,0.2);
}
button.active {
  background: linear-gradient(135deg, #2563eb, #1d4ed8);
  color: white;
  box-shadow: 0 2px 8px rgba(37, 99, 235, 0.3);
}

select {
  background: rgba(255, 255, 255, 0.06);
  color: #e2e8f0;
  border: 1px solid rgba(255, 255, 255, 0.1);
  padding: 9px 12px;
  border-radius: 10px;
  font-size: 0.85em;
  font-family: 'Inter', sans-serif;
  cursor: pointer;
  transition: all 0.2s ease;
  -webkit-appearance: none;
  appearance: none;
  background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 24 24' fill='none' stroke='%2394a3b8' stroke-width='2'%3E%3Cpath d='M6 9l6 6 6-6'/%3E%3C/svg%3E");
  background-repeat: no-repeat;
  background-position: right 8px center;
  padding-right: 28px;
}
select:hover { border-color: rgba(230, 168, 23, 0.3); }
select:focus { outline: none; border-color: rgba(230, 168, 23, 0.5); box-shadow: 0 0 0 2px rgba(230, 168, 23, 0.15); }

label {
  display: flex;
  align-items: center;
  gap: 6px;
  font-size: 0.82em;
  color: #94a3b8;
  font-weight: 500;
}

/* --- Canvas --- */
.canvas-wrap {
  position: relative;
  display: inline-block;
  width: 100%;
  max-width: 920px;
  animation: fadeInUp 0.6s ease-out 0.2s both;
}
canvas {
  border-radius: 16px;
  cursor: pointer;
  width: 100%;
  height: auto;
  display: block;
  border: 1px solid rgba(255, 255, 255, 0.06);
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4), 0 0 0 1px rgba(255,255,255,0.03);
}

/* --- Tooltip --- */
#tooltip {
  position: absolute;
  background: rgba(15, 20, 35, 0.92);
  backdrop-filter: blur(12px);
  -webkit-backdrop-filter: blur(12px);
  color: #e2e8f0;
  padding: 10px 14px;
  border-radius: 10px;
  font-size: 0.8em;
  pointer-events: none;
  display: none;
  z-index: 10;
  line-height: 1.5;
  border: 1px solid rgba(255, 255, 255, 0.1);
  box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
  transition: opacity 0.15s ease;
  font-family: 'Inter', sans-serif;
}

/* --- Legend --- */
.legend {
  display: flex;
  gap: 8px;
  margin-top: 14px;
  flex-wrap: wrap;
  justify-content: center;
  animation: fadeInUp 0.6s ease-out 0.3s both;
}
.legend-item {
  display: flex;
  align-items: center;
  gap: 6px;
  font-size: 0.75em;
  font-weight: 500;
  color: #94a3b8;
  padding: 5px 12px 5px 8px;
  border-radius: 20px;
  background: rgba(255, 255, 255, 0.04);
  border: 1px solid rgba(255, 255, 255, 0.06);
  transition: background 0.2s ease;
}
.legend-item:hover { background: rgba(255, 255, 255, 0.07); }
.legend-dot {
  width: 10px;
  height: 10px;
  border-radius: 50%;
  flex-shrink: 0;
}

/* --- Top List --- */
.top-list {
  margin-top: 14px;
  padding: 16px 20px;
  max-width: 920px;
  width: 100%;
  animation: fadeInUp 0.6s ease-out 0.35s both;
}
.top-list h3 {
  font-size: 0.95em;
  font-weight: 700;
  margin-bottom: 12px;
  background: linear-gradient(135deg, #e6a817, #f0d060);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
}
.top-list ol {
  padding-left: 0;
  list-style: none;
  counter-reset: top-counter;
}
.top-list li {
  counter-increment: top-counter;
  margin-bottom: 6px;
  color: #cbd5e1;
  line-height: 1.5;
  padding: 8px 12px;
  border-radius: 10px;
  background: rgba(255, 255, 255, 0.02);
  border: 1px solid rgba(255, 255, 255, 0.04);
  font-size: 0.82em;
  transition: background 0.2s ease;
  display: flex;
  align-items: baseline;
  gap: 8px;
}
.top-list li:hover { background: rgba(255, 255, 255, 0.05); }
.top-list li::before {
  content: counter(top-counter);
  font-weight: 700;
  color: #475569;
  font-size: 0.85em;
  min-width: 18px;
}
.top-list li span.dots {
  color: #e6a817;
  font-weight: 700;
}
.top-list li span.res {
  color: #64748b;
  font-size: 0.9em;
}
.top-list p { color: #475569; font-size: 0.85em; }

/* --- Info Panel --- */
.info-toggle {
  margin-top: 14px;
  max-width: 920px;
  width: 100%;
  animation: fadeInUp 0.6s ease-out 0.4s both;
}
.info-toggle summary {
  cursor: pointer;
  font-size: 0.82em;
  font-weight: 600;
  color: #64748b;
  padding: 10px 16px;
  border-radius: 12px;
  background: rgba(255, 255, 255, 0.03);
  border: 1px solid rgba(255, 255, 255, 0.05);
  list-style: none;
  display: flex;
  align-items: center;
  gap: 6px;
  transition: all 0.2s ease;
  user-select: none;
}
.info-toggle summary:hover { background: rgba(255, 255, 255, 0.06); color: #94a3b8; }
.info-toggle summary::-webkit-details-marker { display: none; }
.info-toggle summary::before { content: '‚ñ∏'; transition: transform 0.2s ease; display: inline-block; }
.info-toggle[open] summary::before { transform: rotate(90deg); }
.info-content {
  padding: 14px 16px;
  font-size: 0.8em;
  line-height: 1.6;
  color: #64748b;
}
.info-content b { color: #94a3b8; }

/* --- Mobile --- */
@media (max-width: 500px) {
  body { padding: 12px 8px 32px; }
  h1 { font-size: 1.3em; }
  .controls { padding: 10px 12px; gap: 6px; }
  button { padding: 9px 14px; font-size: 0.82em; }
  select { padding: 8px 10px; font-size: 0.82em; }
  .legend { gap: 6px; }
  .legend-item { font-size: 0.7em; padding: 4px 10px 4px 6px; }
  .top-list { padding: 12px 14px; }
  .top-list li { padding: 6px 10px; font-size: 0.78em; }
}
</style>
</head>
<body>

<div class="header">
  <h1 id="mainTitle">üè† Catan Settlement Optimizer</h1>
  <p class="subtitle" id="subtitle">Click tiles to assign numbers ¬∑ see the best settlement spots</p>
</div>

<div class="controls glass">
  <button id="mode4p" class="mode-btn active">4-Player</button>
  <button id="mode6p" class="mode-btn">6-Player</button>
  <label>Assign: <select id="numberSelect">
    <option value="0">Desert</option>
    <option value="2">2</option><option value="3">3</option><option value="4">4</option><option value="5">5</option>
    <option value="6">6</option><option value="8">8</option><option value="9">9</option>
    <option value="10">10</option><option value="11">11</option><option value="12">12</option>
  </select></label>
  <button id="randomBtn">üé≤ Random Board</button>
  <button id="scanBtn">üì∑ Scan Board</button>
  <button id="clearBtn" class="secondary">Clear</button>
  <label>Show top: <select id="topN"><option value="5">5</option><option value="10" selected>10</option><option value="15">15</option><option value="20">20</option></select></label>
  <button id="showAllBtn" class="secondary">üìä All Scores</button>
  <input type="file" id="photoInput" accept="image/*" capture="environment" style="display:none">
</div>

<div class="canvas-wrap">
  <canvas id="board" width="920" height="860"></canvas>
  <div id="tooltip"></div>
</div>

<div class="legend">
  <div class="legend-item"><div class="legend-dot" style="background:#00ff88;box-shadow:0 0 6px #00ff8866;"></div> Best</div>
  <div class="legend-item"><div class="legend-dot" style="background:#ffdd00;box-shadow:0 0 6px #ffdd0066;"></div> Great</div>
  <div class="legend-item"><div class="legend-dot" style="background:#ff8800;box-shadow:0 0 6px #ff880066;"></div> Good</div>
  <div class="legend-item"><div class="legend-dot" style="background:#ff3355;box-shadow:0 0 6px #ff335566;"></div> Weak</div>
  <div class="legend-item"><div class="legend-dot" style="background:#475569;"></div> No value</div>
  <div class="legend-item"><div class="legend-dot" style="background:#1e40af;"></div> Port 3:1</div>
  <div class="legend-item"><div class="legend-dot" style="background:#059669;"></div> Port 2:1</div>
</div>

<div id="resourcePool" class="glass" style="width:100%;max-width:520px;margin:12px auto;padding:16px 20px;border-radius:16px;background:rgba(255,255,255,0.04);backdrop-filter:blur(12px);border:1px solid rgba(255,255,255,0.08);"></div>

<div id="rarityLedger" class="glass" style="width:100%;max-width:520px;margin:12px auto;padding:16px 20px;border-radius:16px;background:rgba(255,255,255,0.04);backdrop-filter:blur(12px);border:1px solid rgba(255,255,255,0.08);"></div>

<div class="top-list glass" id="topList"></div>

<details class="info-toggle">
  <summary>How it works</summary>
  <div class="info-content">
    <b>Scoring Formula:</b> Score = Weighted Pips + Diversity + Number Spread + Port Bonus ‚àí Robber Risk + Expansion
    <br><br>
    <b>‚öñÔ∏è Weighted Pips:</b> Each tile's pip count √ó <b>dynamic scarcity weight</b>. Weights blend strategic value (ore/wheat for cities) with board-specific rarity ‚Äî resources with fewer tiles and lower pip totals get boosted. Check the Rarity Ledger below to see current weights.
    <br><br>
    <b>üìä Resource Probability:</b> Each number has a real probability (e.g. 6/8 = 13.9%, 2/12 = 2.8%). The breakdown shows your expected % chance of getting each resource per roll.
    <br><br>
    <b>üé≤ Diversity Bonus:</b> 3 unique resources = +3, 2 = +1. More types = less trading needed.
    <br><br>
    <b>üéØ Number Spread:</b> 3 different numbers = +2, 2 = +1. Uncorrelated rolls = more consistent income.
    <br><br>
    <b>üö¢ Port Bonus:</b> Matching 2:1 port with that resource = +3, generic 3:1 = +1.5, non-matching 2:1 = +1.
    <br><br>
    <b>üè¥‚Äç‚ò†Ô∏è Robber Risk:</b> If >60% of your pips come from one hex, ‚àí1.5 penalty (robber magnet).
    <br><br>
    <b>üõ§Ô∏è Expansion:</b> Nearby vertices with 4+ pips = better road-building options (up to +3).
    <br><br>
    Click a tile to assign a number, hit Random for a valid layout, or <b>üì∑ Scan Board</b> to
    take a photo of your real Catan board and auto-populate with AI vision.
  </div>
</details>

<script>
let currentMode = '4p'; // '4p' or '6p'
let ROWS = [3,4,5,4,3]; // Start with 4-player
let TOTAL_TILES = 19;

const BOARD_CONFIGS = {
  '4p': {
    rows: [3,4,5,4,3],
    totalTiles: 19,
    resources: { desert: 1, brick: 3, ore: 3, wood: 4, wheat: 4, sheep: 4 },
    tokens: [0, 2,3,3,4,4,5,5,6,6,8,8,9,9,10,10,11,11,12],
    ports: 9, // 4 generic (3:1) + 5 resource-specific (2:1)
    title: "üè† Catan 4P Settlement Optimizer"
  },
  '6p': {
    rows: [3,4,5,6,5,4,3],
    totalTiles: 30,
    resources: { desert: 2, brick: 5, ore: 5, wood: 6, wheat: 6, sheep: 6 },
    tokens: [0,0,2,2,3,3,3,4,4,4,5,5,5,6,6,6,6,8,8,8,8,9,9,9,10,10,10,11,11,11,12,12],
    ports: 11, // 5 generic (3:1) + 6 resource-specific (2:1)
    title: "üè† Catan 6P Settlement Optimizer"
  }
};

const RESOURCE_COLORS = {
  brick: '#b5451d', ore: '#6b7d8a', wood: '#1a7a3a', wheat: '#daa520', sheep: '#7ec850', desert: '#c2b280'
};
const RESOURCE_NAMES = ['brick','ore','wood','wheat','sheep'];
const DOTS = {0:0, 2:1, 3:2, 4:3, 5:4, 6:5, 8:5, 9:4, 10:3, 11:2, 12:1};
const PROB = {0:0, 2:1/36, 3:2/36, 4:3/36, 5:4/36, 6:5/36, 8:5/36, 9:4/36, 10:3/36, 11:2/36, 12:1/36};

// === SCORING ALGORITHM ===
// Dynamic resource scarcity weights based on actual board composition
// Fewer tiles + fewer pips = higher weight (scarcer = more valuable)
const BASE_RESOURCE_WEIGHT = { ore: 1.3, wheat: 1.3, brick: 1.1, wood: 1.1, sheep: 0.9, desert: 0 };

function computeDynamicWeights() {
  const tileCount = {};
  const totalPips = {};
  const RESOURCES = ['ore', 'wheat', 'brick', 'wood', 'sheep'];
  for (const r of RESOURCES) { tileCount[r] = 0; totalPips[r] = 0; }
  
  for (const t of tiles) {
    if (t.resource !== 'desert' && RESOURCES.includes(t.resource)) {
      tileCount[t.resource]++;
      totalPips[t.resource] += (DOTS[t.number] || 0);
    }
  }
  
  const anyAssigned = RESOURCES.some(r => totalPips[r] > 0);
  if (!anyAssigned) return BASE_RESOURCE_WEIGHT;
  
  // Average pips across all resources as baseline
  const allPips = RESOURCES.map(r => totalPips[r]).filter(p => p > 0);
  if (allPips.length === 0) return BASE_RESOURCE_WEIGHT;
  const avgPips = allPips.reduce((a, b) => a + b, 0) / allPips.length;
  
  const weights = { desert: 0 };
  for (const r of RESOURCES) {
    const pips = totalPips[r] || 0.1;
    // Scarcity multiplier: avgPips/thisPips, so rare resources get boosted
    // Clamp between 0.6 and 2.0 to avoid extremes
    const scarcityMult = Math.min(2.0, Math.max(0.6, avgPips / pips));
    // Blend: 50% base weight (strategic value) + 50% scarcity (board-specific)
    weights[r] = Math.round((BASE_RESOURCE_WEIGHT[r] * 0.5 + scarcityMult * 0.5) * 100) / 100;
  }
  return weights;
}

let RESOURCE_WEIGHT = { ...BASE_RESOURCE_WEIGHT };

function scoreVertex(v) {
  if (!v.isLand || v.adjacentTiles.length === 0) return null;

  // 1. Weighted pip count (probability √ó resource scarcity)
  let weightedPips = 0;
  let rawPips = 0;
  const resourceCounts = {};
  const resourceProbs = {};
  const uniqueResources = new Set();
  const adjNumbers = [];

  for (const tIdx of v.adjacentTiles) {
    const t = tiles[tIdx];
    if (t.number === 0 || t.resource === 'desert') continue;
    const pips = DOTS[t.number] || 0;
    const prob = PROB[t.number] || 0;
    const w = RESOURCE_WEIGHT[t.resource] || 1;
    weightedPips += pips * w;
    rawPips += pips;
    uniqueResources.add(t.resource);
    resourceCounts[t.resource] = (resourceCounts[t.resource] || 0) + 1;
    resourceProbs[t.resource] = (resourceProbs[t.resource] || 0) + prob;
    adjNumbers.push(t.number);
  }

  if (rawPips === 0) return null;

  // 2. Diversity bonus: 3 unique = +3, 2 unique = +1, 1 = 0
  const diversity = uniqueResources.size;
  const diversityBonus = diversity >= 3 ? 3 : diversity === 2 ? 1 : 0;

  // 3. Number spread bonus ‚Äî reward different numbers (less correlated rolls)
  const uniqueNumbers = new Set(adjNumbers);
  const spreadBonus = uniqueNumbers.size >= 3 ? 2 : uniqueNumbers.size === 2 ? 1 : 0;

  // 4. Port bonus
  let portBonus = 0;
  if (v.portAccess) {
    if (v.portAccess.type === 'resource' && uniqueResources.has(v.portAccess.resource)) {
      portBonus = 3; // Matching 2:1 port with that resource
    } else if (v.portAccess.type === 'resource') {
      portBonus = 1; // 2:1 port but no matching resource
    } else {
      portBonus = 1.5; // Generic 3:1 port
    }
  }

  // 5. Robber risk penalty ‚Äî if >60% of pips come from one hex, it's a robber magnet
  let robberPenalty = 0;
  if (adjNumbers.length > 1) {
    const maxSinglePip = Math.max(...v.adjacentTiles.map(i => DOTS[tiles[i].number] || 0));
    if (rawPips > 0 && maxSinglePip / rawPips > 0.6) {
      robberPenalty = 1.5;
    }
  }

  // 6. Expansion score ‚Äî count nearby vertices that also have decent value
  let expansionScore = 0;
  const ROAD_DIST = HEX_R * Math.sqrt(3) * 1.2;
  for (const other of vertices) {
    if (other === v || !other.isLand || other.dots === 0) continue;
    const d = Math.hypot(v.x - other.x, v.y - other.y);
    if (d < ROAD_DIST && other.dots >= 4) {
      expansionScore += 0.5;
    }
  }
  expansionScore = Math.min(expansionScore, 3); // Cap

  const totalScore = weightedPips + diversityBonus + spreadBonus + portBonus - robberPenalty + expansionScore;

  return {
    totalScore: Math.round(totalScore * 10) / 10,
    weightedPips: Math.round(weightedPips * 10) / 10,
    rawPips,
    diversity,
    diversityBonus,
    spreadBonus,
    portBonus,
    robberPenalty,
    expansionScore: Math.round(expansionScore * 10) / 10,
    resources: uniqueResources,
    resourceProbs,
    resourceCounts,
    adjNumbers
  };
}

function generateRandomNumbers() {
  const config = BOARD_CONFIGS[currentMode];
  const nums = [...config.tokens];
  for (let i = nums.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [nums[i], nums[j]] = [nums[j], nums[i]];
  }
  return nums;
}

function generateRandomResources() {
  const config = BOARD_CONFIGS[currentMode];
  const res = [];
  for (const [type, count] of Object.entries(config.resources)) {
    res.push(...Array(count).fill(type));
  }
  for (let i = res.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [res[i], res[j]] = [res[j], res[i]];
  }
  return res;
}

let tiles = [];
let oceanTiles = [];
let ports = [];
let vertices = [];

const canvas = document.getElementById('board');
const ctx = canvas.getContext('2d');
const tooltip = document.getElementById('tooltip');

const HEX_R = 40; // Reduced to fit ocean border
const HEX_H = HEX_R * Math.sqrt(3);
const CX = canvas.width / 2;
const CY = canvas.height / 2;

function hexCorner(cx, cy, r, i) {
  const angle = Math.PI / 180 * (60 * i - 30);
  return { x: cx + r * Math.cos(angle), y: cy + r * Math.sin(angle) };
}

function switchMode(newMode) {
  if (newMode === currentMode) return;
  
  currentMode = newMode;
  const config = BOARD_CONFIGS[currentMode];
  ROWS = [...config.rows];
  TOTAL_TILES = config.totalTiles;
  
  // Update title
  document.getElementById('mainTitle').textContent = config.title;
  
  // Update button states
  document.getElementById('mode4p').classList.toggle('active', newMode === '4p');
  document.getElementById('mode6p').classList.toggle('active', newMode === '6p');
  
  // Rebuild board
  buildBoard();
  drawBoard();
}

function buildBoard() {
  tiles = [];
  oceanTiles = [];
  ports = [];
  
  const vSpacing = 1.5 * HEX_R;
  const hSpacing = Math.sqrt(3) * HEX_R;
  const totalHeight = (ROWS.length - 1) * vSpacing;
  const topY = CY - totalHeight / 2;

  let tileIdx = 0;
  for (let r = 0; r < ROWS.length; r++) {
    const count = ROWS[r];
    const y = topY + r * vSpacing;
    const rowWidth = (count - 1) * hSpacing;
    const startX = CX - rowWidth / 2;
    for (let c = 0; c < count; c++) {
      tiles.push({
        cx: startX + c * hSpacing,
        cy: y,
        number: 0,
        resource: 'desert',
        row: r, col: c, idx: tileIdx++
      });
    }
  }
  
  buildOceanAndPorts();
  buildVertices();
}

function buildOceanAndPorts() {
  const hSpacing = Math.sqrt(3) * HEX_R;
  const vSpacing = 1.5 * HEX_R;
  
  function isLandAt(x, y) {
    return tiles.some(t => Math.hypot(x - t.cx, y - t.cy) < HEX_R * 0.5);
  }
  
  // For each land tile, compute all 6 hex neighbor positions.
  // Keep any neighbor that isn't itself a land tile (= ocean).
  const seen = new Set();
  const oceanPositions = [];
  
  // Flat-top hex neighbor offsets (dx, dy) for pointy-top hexes:
  // Pointy-top neighbors at distance hSpacing:
  //   Same row: left (-hSpacing, 0), right (+hSpacing, 0)
  //   Row above: (-hSpacing/2, -vSpacing), (+hSpacing/2, -vSpacing)
  //   Row below: (-hSpacing/2, +vSpacing), (+hSpacing/2, +vSpacing)
  const neighborOffsets = [
    [-hSpacing, 0], [hSpacing, 0],
    [-hSpacing/2, -vSpacing], [hSpacing/2, -vSpacing],
    [-hSpacing/2, vSpacing], [hSpacing/2, vSpacing]
  ];
  
  for (const tile of tiles) {
    for (const [dx, dy] of neighborOffsets) {
      const nx = tile.cx + dx;
      const ny = tile.cy + dy;
      const key = Math.round(nx) + ',' + Math.round(ny);
      if (seen.has(key)) continue;
      seen.add(key);
      if (!isLandAt(nx, ny)) {
        oceanPositions.push({ x: nx, y: ny });
      }
    }
  }
  
  // Create ocean tiles
  oceanTiles = oceanPositions.map((pos, i) => ({
    cx: pos.x,
    cy: pos.y,
    side: 'ocean',
    idx: i
  }));
  
  // Generate ports
  generatePorts();
}

function getCoastalEdges() {
  // Find all edges of land hexes that face outward (no adjacent land hex on the other side)
  const hSpacing = Math.sqrt(3) * HEX_R;
  const edges = [];
  
  for (const tile of tiles) {
    for (let i = 0; i < 6; i++) {
      const c1 = hexCorner(tile.cx, tile.cy, HEX_R, i);
      const c2 = hexCorner(tile.cx, tile.cy, HEX_R, (i + 1) % 6);
      const midX = (c1.x + c2.x) / 2;
      const midY = (c1.y + c2.y) / 2;
      
      // Check if any other land tile shares this edge
      const isCoastal = !tiles.some(other => {
        if (other === tile) return false;
        const d = Math.hypot(other.cx - tile.cx, other.cy - tile.cy);
        if (d > hSpacing * 1.1) return false;
        // Check if the midpoint of this edge is close to the midpoint of one of other's edges
        for (let j = 0; j < 6; j++) {
          const oc1 = hexCorner(other.cx, other.cy, HEX_R, j);
          const oc2 = hexCorner(other.cx, other.cy, HEX_R, (j + 1) % 6);
          const omx = (oc1.x + oc2.x) / 2;
          const omy = (oc1.y + oc2.y) / 2;
          if (Math.hypot(midX - omx, midY - omy) < 5) return true;
        }
        return false;
      });
      
      if (isCoastal) {
        const angle = Math.atan2(midY - CY, midX - CX);
        edges.push({ midX, midY, v1: c1, v2: c2, angle, tileIdx: tile.idx, edgeIdx: i });
      }
    }
  }
  
  // Sort clockwise (starting from top, going clockwise = starting from -PI/2 increasing)
  edges.sort((a, b) => {
    const aa = (a.angle + Math.PI * 2.5 + Math.PI / 2) % (Math.PI * 2);
    const bb = (b.angle + Math.PI * 2.5 + Math.PI / 2) % (Math.PI * 2);
    return aa - bb;
  });
  
  return edges;
}

function generatePorts() {
  const config = BOARD_CONFIGS[currentMode];
  ports = [];
  
  const coastalEdges = getCoastalEdges();
  const totalEdges = coastalEdges.length; // Should be ~18 for 4p, ~24 for 6p
  
  // Standard Catan port types going clockwise from top-left
  // 4-player: 9 ports (4 generic + 5 resource), placed every other coastal edge
  // 6-player: 11 ports (5 generic + 6 resource)
  let portTypes;
  if (currentMode === '4p') {
    // Standard Catan 5th edition beginner layout, clockwise from NW
    portTypes = [
      { type: 'generic', resource: null },    // NW
      { type: 'resource', resource: 'wheat' }, // NE
      { type: 'resource', resource: 'ore' },   // E-upper
      { type: 'generic', resource: null },     // E-lower
      { type: 'resource', resource: 'sheep' }, // SE
      { type: 'generic', resource: null },     // S
      { type: 'generic', resource: null },     // SW
      { type: 'resource', resource: 'brick' }, // W
      { type: 'resource', resource: 'wood' },  // NW-upper
    ];
  } else {
    portTypes = [
      { type: 'generic', resource: null },
      { type: 'resource', resource: 'wheat' },
      { type: 'resource', resource: 'ore' },
      { type: 'generic', resource: null },
      { type: 'resource', resource: 'sheep' },
      { type: 'generic', resource: null },
      { type: 'resource', resource: 'brick' },
      { type: 'generic', resource: null },
      { type: 'resource', resource: 'wood' },
      { type: 'generic', resource: null },
      { type: 'resource', resource: 'wheat' },
    ];
  }
  
  const numPorts = portTypes.length;
  const step = totalEdges / numPorts;
  
  const usedOceanTiles = new Set();
  for (let i = 0; i < numPorts; i++) {
    const edgeIndex = Math.round(i * step) % totalEdges;
    const edge = coastalEdges[edgeIndex];
    
    // Port position = center of the nearest unused ocean tile to the coastal edge midpoint
    const sorted = [...oceanTiles].map((ot, idx) => ({
      idx, cx: ot.cx, cy: ot.cy,
      d: Math.hypot(ot.cx - edge.midX, ot.cy - edge.midY)
    })).sort((a, b) => a.d - b.d);
    let chosen = sorted[0];
    for (const candidate of sorted) {
      if (!usedOceanTiles.has(candidate.idx)) { chosen = candidate; break; }
    }
    usedOceanTiles.add(chosen.idx);
    
    ports.push({
      cx: chosen.cx,
      cy: chosen.cy,
      type: portTypes[i].type,
      resource: portTypes[i].resource,
      ratio: portTypes[i].type === 'generic' ? '3:1' : '2:1',
      // Store the two coastal vertices this port connects to
      vertex1: edge.v1,
      vertex2: edge.v2,
      edgeMid: { x: edge.midX, y: edge.midY }
    });
  }
}

function buildVertices() {
  vertices = [];
  const vMap = new Map();
  const SNAP = 3;
  function snapKey(x, y) {
    const sx = Math.round(x / SNAP) * SNAP;
    const sy = Math.round(y / SNAP) * SNAP;
    return `${sx},${sy}`;
  }
  
  // Add vertices from land tiles
  for (let t = 0; t < tiles.length; t++) {
    const tile = tiles[t];
    for (let i = 0; i < 6; i++) {
      const corner = hexCorner(tile.cx, tile.cy, HEX_R, i);
      const key = snapKey(corner.x, corner.y);
      if (!vMap.has(key)) {
        const vIdx = vertices.length;
        vertices.push({ x: corner.x, y: corner.y, adjacentTiles: [t], key, isLand: true });
        vMap.set(key, vIdx);
      } else {
        const vIdx = vMap.get(key);
        if (!vertices[vIdx].adjacentTiles.includes(t)) {
          vertices[vIdx].adjacentTiles.push(t);
        }
      }
    }
  }
  
  // Add vertices from ocean tiles (for port connections)
  for (let t = 0; t < oceanTiles.length; t++) {
    const tile = oceanTiles[t];
    for (let i = 0; i < 6; i++) {
      const corner = hexCorner(tile.cx, tile.cy, HEX_R, i);
      const key = snapKey(corner.x, corner.y);
      if (!vMap.has(key)) {
        const vIdx = vertices.length;
        vertices.push({ x: corner.x, y: corner.y, adjacentTiles: [], key, isLand: false, oceanTiles: [t] });
        vMap.set(key, vIdx);
      } else {
        const vIdx = vMap.get(key);
        if (!vertices[vIdx].oceanTiles) vertices[vIdx].oceanTiles = [];
        if (!vertices[vIdx].oceanTiles.includes(t)) {
          vertices[vIdx].oceanTiles.push(t);
        }
      }
    }
  }
}

function computeVertexValues() {
  // Recompute dynamic resource weights based on current board state
  RESOURCE_WEIGHT = computeDynamicWeights();
  for (const v of vertices) {
    let totalDots = 0;
    const resources = new Set();
    for (const tIdx of v.adjacentTiles) {
      const t = tiles[tIdx];
      totalDots += DOTS[t.number] || 0;
      if (t.resource !== 'desert' && t.number > 0) resources.add(t.resource);
    }
    v.dots = totalDots;
    v.resources = resources;
    
    // Check for port access ‚Äî vertex must be near one of the port's two coastal vertices
    v.portAccess = null;
    for (const port of ports) {
      if (port.vertex1 && port.vertex2) {
        const d1 = Math.hypot(v.x - port.vertex1.x, v.y - port.vertex1.y);
        const d2 = Math.hypot(v.x - port.vertex2.x, v.y - port.vertex2.y);
        if (d1 < 5 || d2 < 5) {
          v.portAccess = port;
          break;
        }
      }
    }

    // Compute full score
    v.score = scoreVertex(v);
  }
}

function randomizeBoard() {
  const numbers = generateRandomNumbers();
  const resources = generateRandomResources();
  for (let i = 0; i < tiles.length; i++) {
    tiles[i].resource = resources[i];
    tiles[i].number = 0;
  }
  const numberedTokens = numbers.filter(n => n > 0);
  let ni = 0;
  for (let i = 0; i < tiles.length; i++) {
    if (tiles[i].resource === 'desert') {
      tiles[i].number = 0;
    } else {
      tiles[i].number = numberedTokens[ni++] || 0;
    }
  }
}

function drawResourceOverlay() {
  const tileCount = {};
  const totalPips = {};
  for (const r of RESOURCE_NAMES) { tileCount[r] = 0; totalPips[r] = 0; }
  for (const t of tiles) {
    if (t.resource !== 'desert' && RESOURCE_NAMES.includes(t.resource)) {
      tileCount[t.resource]++;
      totalPips[t.resource] += (DOTS[t.number] || 0);
    }
  }
  const anyAssigned = RESOURCE_NAMES.some(r => tileCount[r] > 0);
  if (!anyAssigned) return;

  const dpr = window.devicePixelRatio || 1;
  const boxW = 150 * dpr;
  const lineH = 18 * dpr;
  const padX = 10 * dpr;
  const padY = 8 * dpr;
  const boxH = (RESOURCE_NAMES.length + 1) * lineH + padY * 2;
  const x0 = canvas.width - boxW - 12 * dpr;
  const y0 = 12 * dpr;

  // Background
  ctx.save();
  ctx.globalAlpha = 0.85;
  ctx.fillStyle = '#0f172a';
  ctx.beginPath();
  ctx.roundRect(x0, y0, boxW, boxH, 8 * dpr);
  ctx.fill();
  ctx.globalAlpha = 1;
  ctx.strokeStyle = 'rgba(255,255,255,0.12)';
  ctx.lineWidth = 1;
  ctx.stroke();

  // Title
  ctx.fillStyle = '#e2e8f0';
  ctx.font = `bold ${10 * dpr}px Inter, sans-serif`;
  ctx.textAlign = 'left';
  ctx.textBaseline = 'top';
  ctx.fillText('Resource Distribution', x0 + padX, y0 + padY);

  const maxPips = Math.max(...Object.values(totalPips), 1);
  const labels = { brick:'üß±', ore:'‚õ∞Ô∏è', wood:'üå≤', wheat:'üåæ', sheep:'üêë' };
  const colors = RESOURCE_COLORS;
  const barMaxW = boxW - padX * 2 - 60 * dpr;

  const sorted = [...RESOURCE_NAMES].sort((a, b) => totalPips[b] - totalPips[a]);
  for (let i = 0; i < sorted.length; i++) {
    const r = sorted[i];
    const rowY = y0 + padY + (i + 1) * lineH;
    const barW = Math.max(2, (totalPips[r] / maxPips) * barMaxW);

    // Label
    ctx.fillStyle = '#cbd5e1';
    ctx.font = `500 ${8 * dpr}px Inter, sans-serif`;
    ctx.textAlign = 'left';
    ctx.fillText(`${r}`, x0 + padX, rowY);

    // Bar
    ctx.fillStyle = colors[r];
    ctx.beginPath();
    ctx.roundRect(x0 + padX + 38 * dpr, rowY, barW, 12 * dpr, 3 * dpr);
    ctx.fill();

    // Count
    ctx.fillStyle = '#94a3b8';
    ctx.font = `500 ${7 * dpr}px Inter, sans-serif`;
    ctx.textAlign = 'right';
    ctx.fillText(`${tileCount[r]}√ó ${totalPips[r]}‚ô¶`, x0 + boxW - padX, rowY + 1);
  }
  ctx.restore();
}

function drawBoard() {
  const dpr = window.devicePixelRatio || 1;
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // Radial gradient background
  const grad = ctx.createRadialGradient(CX, CY, 0, CX, CY, canvas.width * 0.6);
  grad.addColorStop(0, '#0f2847');
  grad.addColorStop(0.6, '#0a1a35');
  grad.addColorStop(1, '#060d1f');
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  // Subtle grid dots for texture
  ctx.fillStyle = 'rgba(255,255,255,0.015)';
  for (let x = 0; x < canvas.width; x += 20) {
    for (let y = 0; y < canvas.height; y += 20) {
      ctx.fillRect(x, y, 1, 1);
    }
  }

  // Draw ocean tiles first
  for (const oceanTile of oceanTiles) drawOceanHex(oceanTile);
  
  // Draw ports
  for (const port of ports) drawPort(port);

  // Draw land tiles
  for (const tile of tiles) drawHex(tile);

  // Draw resource distribution overlay (top-right of canvas)
  drawResourceOverlay();

  computeVertexValues();
  const scored = vertices.filter(v => v.isLand && v.score);
  const maxScore = Math.max(...scored.map(v => v.score.totalScore), 1);
  const sorted = [...scored].sort((a, b) => b.score.totalScore - a.score.totalScore);
  const topN = parseInt(document.getElementById('topN').value);
  const topSet = new Set(sorted.slice(0, topN));

  for (const v of scored) {
    const ratio = v.score.totalScore / maxScore;
    const rank = sorted.indexOf(v);
    let color, radius, glowColor;

    if (topSet.has(v) && rank < Math.ceil(topN * 0.3)) {
      color = '#00ff88'; radius = 10; glowColor = 'rgba(0,255,136,0.5)';
    } else if (topSet.has(v) && rank < Math.ceil(topN * 0.6)) {
      color = '#ffdd00'; radius = 9; glowColor = 'rgba(255,221,0,0.4)';
    } else if (topSet.has(v)) {
      color = '#ff8800'; radius = 8; glowColor = 'rgba(255,136,0,0.35)';
    } else if (showAllScores) {
      // Show all scores mode: color by ratio, show numbers
      if (ratio > 0.7) { color = '#66bb6a'; }
      else if (ratio > 0.5) { color = '#42a5f5'; }
      else if (ratio > 0.3) { color = '#ab47bc'; }
      else { color = '#78909c'; }
      radius = 9;
      glowColor = color + '60';
    } else {
      color = `rgba(255,255,255,${0.12 + ratio * 0.3})`;
      radius = 4 + ratio * 3;
      glowColor = null;
    }

    // Glow for top spots (or all scores mode)
    if (glowColor) {
      ctx.save();
      ctx.shadowColor = glowColor;
      ctx.shadowBlur = 12;
      ctx.beginPath();
      ctx.arc(v.x, v.y, radius, 0, Math.PI * 2);
      ctx.fillStyle = color;
      ctx.fill();
      ctx.restore();

      // White ring
      ctx.beginPath();
      ctx.arc(v.x, v.y, radius, 0, Math.PI * 2);
      ctx.strokeStyle = 'rgba(255,255,255,0.6)';
      ctx.lineWidth = 1.5;
      ctx.stroke();

      // Score number on dot
      ctx.fillStyle = '#000';
      ctx.font = 'bold 7px Inter, sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(v.score.totalScore.toFixed(0), v.x, v.y);
    } else {
      ctx.beginPath();
      ctx.arc(v.x, v.y, radius, 0, Math.PI * 2);
      ctx.fillStyle = color;
      ctx.fill();
    }

    // Port indicator on vertex
    if (v.portAccess) {
      const portColor = v.portAccess.type === 'generic' ? '#1e40af' : '#059669';
      ctx.beginPath();
      ctx.arc(v.x - radius - 3, v.y - radius - 3, 3, 0, Math.PI * 2);
      ctx.fillStyle = portColor;
      ctx.fill();
      ctx.strokeStyle = 'white';
      ctx.lineWidth = 1;
      ctx.stroke();
    }
  }

  updateTopList(sorted, topN);
  updateResourcePool();
  updateRarityLedger();
}

function updateResourcePool() {
  const el = document.getElementById('resourcePool');
  const pool = {};
  for (const r of RESOURCE_NAMES) pool[r] = 0;
  for (const t of tiles) {
    if (t.resource !== 'desert' && t.number > 0 && pool.hasOwnProperty(t.resource)) {
      pool[t.resource] += (DOTS[t.number] || 0) / 36;
    }
  }
  const maxProb = Math.max(...Object.values(pool), 0.001);
  const colors = { brick:'#b5451d', ore:'#6b7d8a', wood:'#1a7a3a', wheat:'#daa520', sheep:'#7ec850' };
  const labels = { brick:'üß± Brick', ore:'‚õ∞Ô∏è Ore', wood:'üå≤ Wood', wheat:'üåæ Wheat', sheep:'üêë Sheep' };
  let html = '<div style="font:600 0.95em Inter,sans-serif;color:#e2e8f0;margin-bottom:10px;">üìä Resource Probability Pool</div>';
  for (const r of RESOURCE_NAMES) {
    const pct = (pool[r] * 100).toFixed(1);
    const barW = Math.max(1, (pool[r] / maxProb) * 100);
    html += `<div style="display:flex;align-items:center;gap:8px;margin:5px 0;font:500 0.8em Inter,sans-serif;color:#cbd5e1;">
      <span style="width:80px;text-align:right;">${labels[r]}</span>
      <div style="flex:1;height:14px;background:rgba(255,255,255,0.06);border-radius:7px;overflow:hidden;">
        <div style="width:${barW}%;height:100%;background:${colors[r]};border-radius:7px;transition:width 0.3s;"></div>
      </div>
      <span style="width:45px;font-variant-numeric:tabular-nums;">${pct}%</span>
    </div>`;
  }
  el.innerHTML = html;
}

function updateRarityLedger() {
  const el = document.getElementById('rarityLedger');
  const config = BOARD_CONFIGS[currentMode];
  const totalLand = config.totalTiles - config.resources.desert;
  
  // Count tiles and total pips per resource on this board
  const tileCount = {};
  const totalPips = {};
  for (const r of RESOURCE_NAMES) { tileCount[r] = 0; totalPips[r] = 0; }
  for (const t of tiles) {
    if (t.resource !== 'desert' && RESOURCE_NAMES.includes(t.resource)) {
      tileCount[t.resource]++;
      totalPips[t.resource] += (DOTS[t.number] || 0);
    }
  }
  
  const anyAssigned = RESOURCE_NAMES.some(r => tileCount[r] > 0);
  if (!anyAssigned) {
    el.innerHTML = '<div style="font:600 0.95em Inter,sans-serif;color:#e2e8f0;margin-bottom:6px;">üìã Resource Rarity</div><div style="font:400 0.8em Inter,sans-serif;color:#64748b;">Assign numbers to see rarity breakdown</div>';
    return;
  }

  const maxPips = Math.max(...Object.values(totalPips), 1);
  const colors = { brick:'#b5451d', ore:'#6b7d8a', wood:'#1a7a3a', wheat:'#daa520', sheep:'#7ec850' };
  const labels = { brick:'üß± Brick', ore:'‚õ∞Ô∏è Ore', wood:'üå≤ Wood', wheat:'üåæ Wheat', sheep:'üêë Sheep' };
  
  // Sort by total pips ascending (rarest first)
  const sorted = [...RESOURCE_NAMES].sort((a, b) => totalPips[a] - totalPips[b]);
  
  let html = '<div style="font:600 0.95em Inter,sans-serif;color:#e2e8f0;margin-bottom:10px;">üìã Resource Rarity <span style="font-weight:400;font-size:0.8em;color:#64748b;">‚Äî sorted rarest ‚Üí most common</span></div>';
  
  for (const r of sorted) {
    const pips = totalPips[r];
    const count = tileCount[r];
    const barW = Math.max(2, (pips / maxPips) * 100);
    
    // Rarity tag
    let tag, tagColor;
    const pipRatio = pips / maxPips;
    if (pipRatio <= 0.4) { tag = 'RARE'; tagColor = '#ef4444'; }
    else if (pipRatio <= 0.65) { tag = 'SCARCE'; tagColor = '#f59e0b'; }
    else if (pipRatio <= 0.85) { tag = 'COMMON'; tagColor = '#3b82f6'; }
    else { tag = 'ABUNDANT'; tagColor = '#22c55e'; }
    
    html += `<div style="display:flex;align-items:center;gap:8px;margin:6px 0;font:500 0.8em Inter,sans-serif;color:#cbd5e1;">
      <span style="width:80px;text-align:right;">${labels[r]}</span>
      <div style="flex:1;height:16px;background:rgba(255,255,255,0.06);border-radius:8px;overflow:hidden;position:relative;">
        <div style="width:${barW}%;height:100%;background:${colors[r]};border-radius:8px;transition:width 0.3s;"></div>
      </div>
      <span style="width:30px;text-align:center;font-variant-numeric:tabular-nums;">${count}√ó</span>
      <span style="width:40px;text-align:center;font-variant-numeric:tabular-nums;">${pips}‚ô¶</span>
      <span style="width:65px;text-align:center;font-size:0.75em;font-weight:700;color:${tagColor};background:${tagColor}18;padding:2px 6px;border-radius:4px;">${tag}</span>
      <span style="width:40px;text-align:center;font-size:0.72em;color:#94a3b8;" title="Dynamic weight">${RESOURCE_WEIGHT[r].toFixed(2)}√ó</span>
    </div>`;
  }
  
  el.innerHTML = html;
}

function drawOceanHex(oceanTile) {
  const corners = [];
  for (let i = 0; i < 6; i++) corners.push(hexCorner(oceanTile.cx, oceanTile.cy, HEX_R - 1, i));

  // Ocean hex fill with wave-like gradient
  ctx.beginPath();
  ctx.moveTo(corners[0].x, corners[0].y);
  for (let i = 1; i < 6; i++) ctx.lineTo(corners[i].x, corners[i].y);
  ctx.closePath();

  // Deep blue ocean with subtle gradient
  const oceanGrad = ctx.createRadialGradient(oceanTile.cx - 10, oceanTile.cy - 10, 0, oceanTile.cx, oceanTile.cy, HEX_R);
  oceanGrad.addColorStop(0, '#1e3a8a');
  oceanGrad.addColorStop(0.5, '#1e40af');
  oceanGrad.addColorStop(1, '#1d4ed8');
  ctx.fillStyle = oceanGrad;
  ctx.fill();

  // Subtle wave texture
  const waveGrad = ctx.createLinearGradient(
    oceanTile.cx - HEX_R, oceanTile.cy - HEX_R,
    oceanTile.cx + HEX_R, oceanTile.cy + HEX_R
  );
  waveGrad.addColorStop(0, 'rgba(255,255,255,0.05)');
  waveGrad.addColorStop(0.3, 'rgba(255,255,255,0.15)');
  waveGrad.addColorStop(0.7, 'rgba(255,255,255,0.05)');
  waveGrad.addColorStop(1, 'rgba(255,255,255,0.1)');
  ctx.fillStyle = waveGrad;
  ctx.fill();

  // Border
  ctx.strokeStyle = 'rgba(30,58,138,0.8)';
  ctx.lineWidth = 1;
  ctx.stroke();
}

function drawPort(port) {
  // Draw connection lines from port to its two coastal vertices
  if (port.vertex1 && port.vertex2) {
    [port.vertex1, port.vertex2].forEach(v => {
      ctx.beginPath();
      ctx.moveTo(port.cx, port.cy);
      ctx.lineTo(v.x, v.y);
      ctx.strokeStyle = 'rgba(255,255,255,0.35)';
      ctx.lineWidth = 1.5;
      ctx.setLineDash([4, 3]);
      ctx.stroke();
      ctx.setLineDash([]);
    });
  }

  // Port symbol background
  ctx.beginPath();
  ctx.arc(port.cx, port.cy, 14, 0, Math.PI * 2);
  const PORT_RESOURCE_COLORS = { brick: '#b5451d', ore: '#6b7d8a', wood: '#1a7a3a', wheat: '#daa520', sheep: '#7ec850' };
  ctx.fillStyle = port.type === 'generic' ? '#1e40af' : (PORT_RESOURCE_COLORS[port.resource] || '#059669');
  ctx.fill();
  ctx.strokeStyle = 'rgba(255,255,255,0.8)';
  ctx.lineWidth = 1.5;
  ctx.stroke();

  // Port ratio text
  ctx.fillStyle = 'white';
  ctx.font = 'bold 8px Inter, sans-serif';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(port.ratio, port.cx, port.cy - 2);

  // Resource icon for resource-specific ports
  if (port.type === 'resource' && port.resource) {
    ctx.font = 'bold 6px Inter, sans-serif';
    ctx.fillText(port.resource.substring(0, 2).toUpperCase(), port.cx, port.cy + 7);
  }
}

function drawHex(tile) {
  const corners = [];
  for (let i = 0; i < 6; i++) corners.push(hexCorner(tile.cx, tile.cy, HEX_R - 2, i));

  // Hex fill
  ctx.beginPath();
  ctx.moveTo(corners[0].x, corners[0].y);
  for (let i = 1; i < 6; i++) ctx.lineTo(corners[i].x, corners[i].y);
  ctx.closePath();

  const baseColor = RESOURCE_COLORS[tile.resource] || '#555';
  ctx.fillStyle = baseColor;
  ctx.fill();

  // Subtle inner gradient for depth
  const innerGrad = ctx.createRadialGradient(tile.cx - 8, tile.cy - 8, 0, tile.cx, tile.cy, HEX_R);
  innerGrad.addColorStop(0, 'rgba(255,255,255,0.1)');
  innerGrad.addColorStop(1, 'rgba(0,0,0,0.15)');
  ctx.fillStyle = innerGrad;
  ctx.fill();

  // Border
  ctx.strokeStyle = 'rgba(0,0,0,0.4)';
  ctx.lineWidth = 2;
  ctx.stroke();
  // Lighter inner border
  const innerCorners = [];
  for (let i = 0; i < 6; i++) innerCorners.push(hexCorner(tile.cx, tile.cy, HEX_R - 4, i));
  ctx.beginPath();
  ctx.moveTo(innerCorners[0].x, innerCorners[0].y);
  for (let i = 1; i < 6; i++) ctx.lineTo(innerCorners[i].x, innerCorners[i].y);
  ctx.closePath();
  ctx.strokeStyle = 'rgba(255,255,255,0.08)';
  ctx.lineWidth = 1;
  ctx.stroke();

  // Number token
  if (tile.number > 0) {
    const isHot = tile.number === 6 || tile.number === 8;

    // Token shadow
    ctx.save();
    ctx.shadowColor = 'rgba(0,0,0,0.4)';
    ctx.shadowBlur = 6;
    ctx.shadowOffsetY = 2;
    ctx.beginPath();
    ctx.arc(tile.cx, tile.cy, 15, 0, Math.PI * 2);
    ctx.fillStyle = '#f5f0dc';
    ctx.fill();
    ctx.restore();

    // Token border
    ctx.beginPath();
    ctx.arc(tile.cx, tile.cy, 15, 0, Math.PI * 2);
    ctx.strokeStyle = isHot ? 'rgba(204,0,0,0.3)' : 'rgba(0,0,0,0.15)';
    ctx.lineWidth = 1.5;
    ctx.stroke();

    ctx.fillStyle = isHot ? '#cc0000' : '#1a1a2e';
    ctx.font = isHot ? 'bold 13px Inter, sans-serif' : '600 12px Inter, sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(tile.number, tile.cx, tile.cy - 1);

    // Dots
    const d = DOTS[tile.number];
    const dotY = tile.cy + 9;
    const dotStart = tile.cx - (d - 1) * 2.5;
    ctx.fillStyle = isHot ? '#cc0000' : '#888';
    for (let i = 0; i < d; i++) {
      ctx.beginPath();
      ctx.arc(dotStart + i * 5, dotY, 1.5, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  // Resource label
  ctx.fillStyle = 'rgba(255,255,255,0.65)';
  ctx.font = '500 7px Inter, sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText(tile.resource, tile.cx, tile.cy + (tile.number > 0 ? 20 : 4));
}

function updateTopList(sorted, topN) {
  const el = document.getElementById('topList');
  const shown = sorted.slice(0, topN);
  if (shown.length === 0) {
    el.innerHTML = '<h3>Top Settlement Spots</h3><p>Assign numbers to tiles first (click tiles or hit Random)</p>';
    return;
  }
  let html = `<h3>Top ${topN} Settlement Spots</h3><ol>`;
  for (const v of shown) {
    const s = v.score;
    const resList = v.adjacentTiles.map(i => {
      const t = tiles[i];
      return t.number > 0 ? `${t.resource}(${t.number})` : null;
    }).filter(Boolean).join(', ');
    
    const portText = v.portAccess ? ` üö¢${v.portAccess.ratio}${v.portAccess.resource ? ' ' + v.portAccess.resource : ''}` : '';
    
    // Resource probability spread
    const probParts = Object.entries(s.resourceProbs).map(([res, prob]) => 
      `${res}: ${(prob * 100).toFixed(1)}%`
    ).join(', ');
    
    // Score breakdown chips
    let chips = `<span class="dots">${s.totalScore}</span> `;
    chips += `<span class="res">‚Äî ${resList || 'none'}${portText}</span>`;
    chips += `<br><span class="res" style="font-size:0.85em;color:#475569;">`;
    chips += `‚öñÔ∏è${s.weightedPips} wpips ¬∑ üé≤${s.diversity} types ¬∑ üìä${probParts}`;
    if (s.robberPenalty > 0) chips += ` ¬∑ üè¥‚Äç‚ò†Ô∏è-${s.robberPenalty}`;
    if (s.portBonus > 0) chips += ` ¬∑ üö¢+${s.portBonus}`;
    if (s.expansionScore > 0) chips += ` ¬∑ üõ§Ô∏è+${s.expansionScore}`;
    if (s.spreadBonus > 0) chips += ` ¬∑ üéØ+${s.spreadBonus} spread`;
    chips += `</span>`;
    
    html += `<li>${chips}</li>`;
  }
  html += '</ol>';
  el.innerHTML = html;
}

// Click handling
canvas.addEventListener('click', (e) => {
  const rect = canvas.getBoundingClientRect();
  const mx = (e.clientX - rect.left) * (canvas.width / rect.width);
  const my = (e.clientY - rect.top) * (canvas.height / rect.height);
  let closest = null, minDist = Infinity;
  for (const tile of tiles) {
    const d = Math.hypot(mx - tile.cx, my - tile.cy);
    if (d < HEX_R && d < minDist) { closest = tile; minDist = d; }
  }
  if (closest) {
    const num = parseInt(document.getElementById('numberSelect').value);
    closest.number = num;
    if (num === 0) closest.resource = 'desert';
    else if (closest.resource === 'desert') {
      closest.resource = RESOURCE_NAMES[Math.floor(Math.random() * RESOURCE_NAMES.length)];
    }
    drawBoard();
  }
});

// Tooltip
canvas.addEventListener('mousemove', (e) => {
  const rect = canvas.getBoundingClientRect();
  const mx = (e.clientX - rect.left) * (canvas.width / rect.width);
  const my = (e.clientY - rect.top) * (canvas.height / rect.height);
  let closest = null, minDist = Infinity;
  for (const v of vertices) {
    if (v.dots === 0 || !v.isLand) continue;
    const d = Math.hypot(mx - v.x, my - v.y);
    if (d < 15 && d < minDist) { closest = v; minDist = d; }
  }
  if (closest && closest.score) {
    const s = closest.score;
    const lines = [`<b>Score: ${s.totalScore}</b>`];
    lines.push(`<b>${s.rawPips} pips</b> (weighted: ${s.weightedPips})`);
    for (const tIdx of closest.adjacentTiles) {
      const t = tiles[tIdx];
      if (t.number > 0) {
        const prob = (PROB[t.number] * 100).toFixed(1);
        lines.push(`${t.resource} ${t.number} ‚Äî ${prob}% chance/roll`);
      }
    }
    lines.push(`Diversity: ${s.diversity} type${s.diversity !== 1 ? 's' : ''} (+${s.diversityBonus})`);
    if (s.spreadBonus > 0) lines.push(`Number spread: +${s.spreadBonus}`);
    if (s.portBonus > 0) lines.push(`Port: ${closest.portAccess.ratio} ${closest.portAccess.resource || 'any'} (+${s.portBonus})`);
    if (s.robberPenalty > 0) lines.push(`Robber risk: -${s.robberPenalty}`);
    if (s.expansionScore > 0) lines.push(`Expansion: +${s.expansionScore}`);
    tooltip.innerHTML = lines.join('<br>');
    tooltip.style.display = 'block';
    tooltip.style.left = (e.clientX - rect.left + 15) + 'px';
    tooltip.style.top = (e.clientY - rect.top - 10) + 'px';
  } else {
    tooltip.style.display = 'none';
  }
});
canvas.addEventListener('mouseleave', () => { tooltip.style.display = 'none'; });

// Event listeners
document.getElementById('mode4p').addEventListener('click', () => switchMode('4p'));
document.getElementById('mode6p').addEventListener('click', () => switchMode('6p'));
document.getElementById('randomBtn').addEventListener('click', () => { randomizeBoard(); drawBoard(); });
document.getElementById('clearBtn').addEventListener('click', () => {
  for (const t of tiles) { t.number = 0; t.resource = 'desert'; }
  drawBoard();
});
document.getElementById('topN').addEventListener('change', drawBoard);

let showAllScores = false;
document.getElementById('showAllBtn').addEventListener('click', () => {
  showAllScores = !showAllScores;
  document.getElementById('showAllBtn').classList.toggle('active', showAllScores);
  document.getElementById('showAllBtn').textContent = showAllScores ? 'üìä Top Only' : 'üìä All Scores';
  drawBoard();
});

// --- Photo Scan Feature ---
const scanBtn = document.getElementById('scanBtn');
const photoInput = document.getElementById('photoInput');

function getApiKey() {
  let key = localStorage.getItem('openai_api_key');
  if (key) return key;
  key = prompt('Enter your OpenAI API key to use board scanning.\nIt\'s stored locally in your browser only.\n\nGet one at platform.openai.com/api-keys');
  if (key && key.startsWith('sk-')) {
    localStorage.setItem('openai_api_key', key);
    return key;
  }
  return null;
}

scanBtn.addEventListener('click', () => {
  const key = getApiKey();
  if (!key) return;
  photoInput.click();
});

photoInput.addEventListener('change', async (e) => {
  const file = e.target.files[0];
  if (!file) return;
  const key = localStorage.getItem('openai_api_key');
  if (!key) return;

  scanBtn.textContent = '‚è≥ Analyzing...';
  scanBtn.disabled = true;

  try {
    const base64 = await new Promise((resolve) => {
      const reader = new FileReader();
      reader.onload = () => resolve(reader.result.split(',')[1]);
      reader.readAsDataURL(file);
    });

    const response = await fetch('https://api.openai.com/v1/chat/completions', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${key}` },
      body: JSON.stringify({
        model: 'gpt-4o',
        max_tokens: 1500,
        messages: [{
          role: 'user',
          content: [
            { type: 'text', text: `Analyze this photo of a Catan board. The board has hex tiles arranged in rows of [3,4,5,6,5,4,3] (30 tiles total for 6-player, or [3,4,5,4,3] = 19 tiles for standard).

For each tile, identify:
1. The resource type: brick (red/brown hills), ore (grey mountains), wood (dark green forest), wheat (yellow fields), sheep (light green pastures), or desert (tan/sandy, no number)
2. The number token on it (2-12, or 0 for desert)

Return ONLY a JSON array of objects, one per tile, in row-by-row order (top row left-to-right, then next row, etc.):
[{"resource":"wheat","number":5},{"resource":"ore","number":8},...]

If you can't identify a tile clearly, use your best guess. Desert tiles have number 0.` },
            { type: 'image_url', image_url: { url: `data:image/jpeg;base64,${base64}` } }
          ]
        }]
      })
    });

    const data = await response.json();
    if (data.error) {
      if (data.error.code === 'invalid_api_key') {
        localStorage.removeItem('openai_api_key');
        alert('Invalid API key. It has been cleared ‚Äî try again.');
      } else {
        alert('API error: ' + data.error.message);
      }
      return;
    }

    const content = data.choices[0].message.content;
    const jsonMatch = content.match(/\[[\s\S]*\]/);
    if (!jsonMatch) {
      alert('Could not parse board from image. Try a clearer photo.');
      return;
    }

    const parsed = JSON.parse(jsonMatch[0]);
    if (parsed.length === 19) {
      switchMode('4p');
    } else if (parsed.length >= 28 && parsed.length <= 30) {
      switchMode('6p');
    }

    const count = Math.min(parsed.length, tiles.length);
    for (let i = 0; i < count; i++) {
      const p = parsed[i];
      tiles[i].resource = p.resource || 'desert';
      tiles[i].number = parseInt(p.number) || 0;
      if (tiles[i].number === 0) tiles[i].resource = 'desert';
    }

    drawBoard();
    alert(`‚úÖ Board scanned! ${count} tiles detected.`);
  } catch (err) {
    console.error(err);
    alert('Failed to analyze image: ' + err.message);
  } finally {
    scanBtn.textContent = 'üì∑ Scan Board';
    scanBtn.disabled = false;
    photoInput.value = '';
  }
});

// Init
buildBoard();
randomizeBoard();
drawBoard();
</script>
</body>
</html>