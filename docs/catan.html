<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Catan Settlement Optimizer</title>

<!-- #11: Meta tags / OG -->
<meta name="description" content="Find the best settlement spots on any Catan board. AI-powered scoring with resource scarcity, port bonuses, and complementary settlement planning.">
<meta property="og:title" content="Catan Settlement Optimizer">
<meta property="og:description" content="AI-powered Catan board analysis. Find optimal settlement spots with composite scoring.">
<meta property="og:image" content="https://peytoncampbell.ca/catan/og-image.png">
<meta property="og:url" content="https://peytoncampbell.ca/catan">
<meta property="og:type" content="website">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:title" content="Catan Settlement Optimizer">
<meta name="twitter:description" content="AI-powered Catan board analysis. Find optimal settlement spots.">
<meta name="twitter:image" content="https://peytoncampbell.ca/catan/og-image.png">

<!-- #10: Favicon -->
<link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üè†</text></svg>">

<link rel="preconnect" href="https://fonts.googleapis.com">
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
<style>
@keyframes fadeInUp {
  from { opacity: 0; transform: translateY(20px); }
  to { opacity: 1; transform: translateY(0); }
}
@keyframes shimmer {
  0% { background-position: -200% 0; }
  100% { background-position: 200% 0; }
}
@keyframes subtlePulse {
  0%, 100% { opacity: 0.6; }
  50% { opacity: 1; }
}
@keyframes toastIn {
  from { opacity: 0; transform: translateY(20px); }
  to { opacity: 1; transform: translateY(0); }
}
@keyframes toastOut {
  from { opacity: 1; transform: translateY(0); }
  to { opacity: 0; transform: translateY(-10px); }
}

* { margin: 0; padding: 0; box-sizing: border-box; }

body {
  background: #0a0e1a;
  color: #e2e8f0;
  font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
  display: flex;
  flex-direction: column;
  align-items: center;
  min-height: 100vh;
  padding: 12px 12px 32px;
  animation: fadeInUp 0.6s ease-out;
}

/* --- Header --- */
.header {
  text-align: center;
  margin-bottom: 10px;
  animation: fadeInUp 0.5s ease-out;
}
h1 {
  font-size: 1.5em;
  font-weight: 800;
  letter-spacing: -0.02em;
  background: linear-gradient(135deg, #e6a817, #f0d060);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
}
.subtitle {
  color: #64748b;
  font-size: 0.82em;
  font-weight: 400;
  margin-top: 2px;
}

/* --- Glass Card Mixin --- */
.glass {
  background: rgba(255, 255, 255, 0.04);
  backdrop-filter: blur(16px);
  -webkit-backdrop-filter: blur(16px);
  border: 1px solid rgba(255, 255, 255, 0.07);
  border-radius: 14px;
}

/* --- Controls Bar --- */
.controls {
  display: flex;
  gap: 8px;
  margin-bottom: 10px;
  flex-wrap: wrap;
  justify-content: center;
  align-items: center;
  padding: 10px 14px;
  max-width: 920px;
  width: 100%;
  animation: fadeInUp 0.6s ease-out 0.1s both;
}

button {
  background: linear-gradient(135deg, #e6a817, #d49b10);
  color: #0a0e1a;
  border: none;
  padding: 9px 16px;
  border-radius: 10px;
  cursor: pointer;
  font-weight: 600;
  font-size: 0.82em;
  font-family: 'Inter', sans-serif;
  touch-action: manipulation;
  -webkit-tap-highlight-color: transparent;
  transition: all 0.2s ease;
  box-shadow: 0 2px 8px rgba(230, 168, 23, 0.2);
  white-space: nowrap;
}
button:hover {
  transform: translateY(-1px) scale(1.02);
  box-shadow: 0 4px 16px rgba(230, 168, 23, 0.35);
  background: linear-gradient(135deg, #f0c040, #e6a817);
}
button:active {
  transform: scale(0.97);
  box-shadow: 0 1px 4px rgba(230, 168, 23, 0.2);
}
button.secondary {
  background: rgba(255, 255, 255, 0.06);
  color: #94a3b8;
  box-shadow: none;
  border: 1px solid rgba(255, 255, 255, 0.08);
}
button.secondary:hover {
  background: rgba(255, 255, 255, 0.1);
  color: #e2e8f0;
  box-shadow: 0 2px 8px rgba(0,0,0,0.2);
}
button.active {
  background: linear-gradient(135deg, #2563eb, #1d4ed8);
  color: white;
  box-shadow: 0 2px 8px rgba(37, 99, 235, 0.3);
}
button.settle-mode {
  background: linear-gradient(135deg, #059669, #047857);
  color: white;
  box-shadow: 0 2px 8px rgba(5, 150, 105, 0.3);
}
button.settle-mode.active {
  background: linear-gradient(135deg, #10b981, #059669);
  box-shadow: 0 2px 12px rgba(16, 185, 129, 0.4);
}

select {
  background: rgba(255, 255, 255, 0.06);
  color: #e2e8f0;
  border: 1px solid rgba(255, 255, 255, 0.1);
  padding: 8px 12px;
  border-radius: 10px;
  font-size: 0.82em;
  font-family: 'Inter', sans-serif;
  cursor: pointer;
  transition: all 0.2s ease;
  -webkit-appearance: none;
  appearance: none;
  background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 24 24' fill='none' stroke='%2394a3b8' stroke-width='2'%3E%3Cpath d='M6 9l6 6 6-6'/%3E%3C/svg%3E");
  background-repeat: no-repeat;
  background-position: right 8px center;
  padding-right: 28px;
}
select:hover { border-color: rgba(230, 168, 23, 0.3); }
select:focus { outline: none; border-color: rgba(230, 168, 23, 0.5); box-shadow: 0 0 0 2px rgba(230, 168, 23, 0.15); }

label {
  display: flex;
  align-items: center;
  gap: 6px;
  font-size: 0.8em;
  color: #94a3b8;
  font-weight: 500;
}

/* --- Legend (#6: moved above canvas, integrated) --- */
.legend {
  display: flex;
  gap: 6px;
  margin-bottom: 6px;
  flex-wrap: wrap;
  justify-content: center;
  animation: fadeInUp 0.6s ease-out 0.15s both;
  max-width: 920px;
  width: 100%;
}
.legend-item {
  display: flex;
  align-items: center;
  gap: 5px;
  font-size: 0.72em;
  font-weight: 500;
  color: #94a3b8;
  padding: 4px 10px 4px 7px;
  border-radius: 20px;
  background: rgba(255, 255, 255, 0.04);
  border: 1px solid rgba(255, 255, 255, 0.06);
  transition: background 0.2s ease;
}
.legend-item:hover { background: rgba(255, 255, 255, 0.07); }
.legend-dot {
  width: 9px;
  height: 9px;
  border-radius: 50%;
  flex-shrink: 0;
}

/* --- Canvas (#1: tighter) --- */
.canvas-wrap {
  position: relative;
  display: inline-block;
  width: 100%;
  max-width: 920px;
  animation: fadeInUp 0.6s ease-out 0.2s both;
}
canvas {
  border-radius: 14px;
  cursor: pointer;
  width: 100%;
  height: auto;
  display: block;
  border: 1px solid rgba(255, 255, 255, 0.06);
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4), 0 0 0 1px rgba(255,255,255,0.03);
}

/* --- Tooltip --- */
#tooltip {
  position: absolute;
  background: rgba(15, 20, 35, 0.92);
  backdrop-filter: blur(12px);
  -webkit-backdrop-filter: blur(12px);
  color: #e2e8f0;
  padding: 10px 14px;
  border-radius: 10px;
  font-size: 0.8em;
  pointer-events: none;
  display: none;
  z-index: 10;
  line-height: 1.5;
  border: 1px solid rgba(255, 255, 255, 0.1);
  box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
  transition: opacity 0.15s ease;
  font-family: 'Inter', sans-serif;
  max-width: 280px;
}

/* --- Settlement Plan Panel (#8) --- */
.settle-panel {
  max-width: 920px;
  width: 100%;
  margin-top: 10px;
  padding: 14px 18px;
  display: none;
  animation: fadeInUp 0.3s ease-out;
}
.settle-panel.visible { display: block; }
.settle-panel h3 {
  font-size: 0.92em;
  font-weight: 700;
  margin-bottom: 10px;
  color: #10b981;
}
.settle-picks {
  display: flex;
  gap: 12px;
  flex-wrap: wrap;
  margin-bottom: 10px;
}
.settle-pick {
  flex: 1;
  min-width: 200px;
  padding: 12px;
  border-radius: 12px;
  background: rgba(255,255,255,0.03);
  border: 1px solid rgba(255,255,255,0.06);
}
.settle-pick h4 {
  font-size: 0.85em;
  font-weight: 600;
  margin-bottom: 6px;
  color: #94a3b8;
}
.settle-pick .pick-score {
  font-size: 1.4em;
  font-weight: 800;
  color: #e6a817;
}
.settle-pick .pick-resources {
  display: flex;
  gap: 4px;
  flex-wrap: wrap;
  margin-top: 6px;
}
.settle-combined {
  padding: 10px 14px;
  border-radius: 10px;
  background: rgba(16,185,129,0.08);
  border: 1px solid rgba(16,185,129,0.15);
  font-size: 0.82em;
  color: #a7f3d0;
}

/* --- Resource Distribution (#2: proper HTML element) --- */
.resource-dist {
  max-width: 920px;
  width: 100%;
  margin-top: 10px;
  padding: 14px 18px;
}
.resource-dist h3 {
  font-size: 0.9em;
  font-weight: 700;
  margin-bottom: 10px;
  color: #e2e8f0;
}
.res-row {
  display: flex;
  align-items: center;
  gap: 8px;
  margin: 5px 0;
  font-size: 0.82em;
  color: #cbd5e1;
}
.res-label { width: 75px; text-align: right; font-weight: 500; }
.res-bar-wrap { flex: 1; height: 16px; background: rgba(255,255,255,0.06); border-radius: 8px; overflow: hidden; }
.res-bar { height: 100%; border-radius: 8px; transition: width 0.3s; }
.res-stat { width: 55px; font-variant-numeric: tabular-nums; text-align: right; font-size: 0.9em; color: #94a3b8; }
.res-weight { width: 42px; text-align: center; font-size: 0.75em; color: #64748b; }

/* --- Top List (#3: card redesign) --- */
.top-list {
  margin-top: 10px;
  padding: 16px 18px;
  max-width: 920px;
  width: 100%;
  animation: fadeInUp 0.6s ease-out 0.35s both;
}
.top-list h3 {
  font-size: 0.95em;
  font-weight: 700;
  margin-bottom: 12px;
  background: linear-gradient(135deg, #e6a817, #f0d060);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
}
.top-card {
  display: flex;
  align-items: flex-start;
  gap: 12px;
  padding: 10px 14px;
  border-radius: 10px;
  margin-bottom: 6px;
  border: 1px solid rgba(255,255,255,0.04);
  transition: background 0.2s ease;
}
.top-card:nth-child(odd) { background: rgba(255,255,255,0.02); }
.top-card:nth-child(even) { background: rgba(255,255,255,0.04); }
.top-card:hover { background: rgba(255,255,255,0.07); }
.top-rank {
  min-width: 32px;
  height: 32px;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 8px;
  font-weight: 800;
  font-size: 0.85em;
  flex-shrink: 0;
}
.top-rank.gold { background: linear-gradient(135deg, #f59e0b, #d97706); color: #000; }
.top-rank.silver { background: linear-gradient(135deg, #94a3b8, #64748b); color: #000; }
.top-rank.bronze { background: linear-gradient(135deg, #c2855a, #92400e); color: #000; }
.top-rank.normal { background: rgba(255,255,255,0.06); color: #475569; }
.top-score {
  font-size: 1.3em;
  font-weight: 800;
  color: #e6a817;
  min-width: 44px;
  text-align: center;
  line-height: 1.1;
}
.top-score small {
  font-size: 0.45em;
  font-weight: 500;
  color: #64748b;
  display: block;
}
.top-detail { flex: 1; min-width: 0; }
.top-resources {
  display: flex;
  gap: 4px;
  flex-wrap: wrap;
  margin-bottom: 4px;
}
.res-chip {
  display: inline-flex;
  align-items: center;
  gap: 3px;
  padding: 2px 8px;
  border-radius: 6px;
  font-size: 0.75em;
  font-weight: 600;
  color: white;
}
.top-stats {
  font-size: 0.72em;
  color: #475569;
  display: flex;
  gap: 8px;
  flex-wrap: wrap;
  margin-top: 2px;
}
.top-stats span { white-space: nowrap; }
.top-list p { color: #475569; font-size: 0.85em; }

/* --- Info Panel (#9: more prominent) --- */
.info-panel {
  margin-top: 10px;
  max-width: 920px;
  width: 100%;
  animation: fadeInUp 0.6s ease-out 0.4s both;
}
.info-panel summary {
  cursor: pointer;
  font-size: 0.82em;
  font-weight: 600;
  color: #94a3b8;
  padding: 12px 16px;
  border-radius: 12px;
  list-style: none;
  display: flex;
  align-items: center;
  gap: 8px;
  transition: all 0.2s ease;
  user-select: none;
}
.info-panel summary:hover { background: rgba(255, 255, 255, 0.06); color: #e2e8f0; }
.info-panel summary::-webkit-details-marker { display: none; }
.info-panel summary::before { content: '‚ñ∏'; transition: transform 0.2s ease; display: inline-block; }
.info-panel[open] summary::before { transform: rotate(90deg); }
.info-teaser {
  font-size: 0.72em;
  font-weight: 400;
  color: #64748b;
  margin-left: auto;
}
.info-content {
  padding: 14px 16px;
  font-size: 0.8em;
  line-height: 1.6;
  color: #64748b;
}
.info-content b { color: #94a3b8; }

/* --- Toast --- */
.toast {
  position: fixed;
  bottom: 24px;
  left: 50%;
  transform: translateX(-50%);
  background: rgba(16, 185, 129, 0.95);
  color: white;
  padding: 10px 20px;
  border-radius: 10px;
  font-size: 0.85em;
  font-weight: 600;
  font-family: 'Inter', sans-serif;
  z-index: 1000;
  pointer-events: none;
  animation: toastIn 0.3s ease-out, toastOut 0.3s ease-in 1.5s forwards;
  box-shadow: 0 4px 16px rgba(0,0,0,0.3);
}

/* --- Mobile (#4) --- */
@media (max-width: 768px) {
  body { padding: 8px 6px 24px; }
  h1 { font-size: 1.2em; }
  .subtitle { font-size: 0.75em; }
  .controls { padding: 8px 10px; gap: 5px; }
  button { padding: 8px 12px; font-size: 0.78em; }
  select { padding: 7px 10px; font-size: 0.78em; }
  .legend { gap: 4px; }
  .legend-item { font-size: 0.65em; padding: 3px 7px 3px 5px; }
  .legend-dot { width: 7px; height: 7px; }
  .resource-dist { padding: 10px 12px; }
  .res-label { width: 60px; font-size: 0.9em; }
  .top-list { padding: 10px 12px; }
  .top-card { padding: 8px 10px; gap: 8px; }
  .top-score { font-size: 1.1em; min-width: 36px; }
  .top-rank { min-width: 26px; height: 26px; font-size: 0.75em; }
  .settle-picks { flex-direction: column; }
  .settle-pick { min-width: unset; }
}
@media (max-width: 480px) {
  .controls { padding: 6px 8px; gap: 4px; }
  button { padding: 7px 10px; font-size: 0.75em; }
  .top-stats { font-size: 0.65em; }
  .res-chip { font-size: 0.7em; padding: 1px 6px; }
  .info-teaser { display: none; }
}
</style>
</head>
<body>

<div class="header">
  <h1 id="mainTitle">üè† Catan Settlement Optimizer</h1>
  <p class="subtitle" id="subtitle">Click tiles to assign numbers ¬∑ see the best settlement spots</p>
</div>

<div class="controls glass">
  <button id="mode4p" class="mode-btn active">4-Player</button>
  <button id="mode6p" class="mode-btn">6-Player</button>
  <label>Assign: <select id="numberSelect">
    <option value="0">Desert</option>
    <option value="2">2</option><option value="3">3</option><option value="4">4</option><option value="5">5</option>
    <option value="6">6</option><option value="8">8</option><option value="9">9</option>
    <option value="10">10</option><option value="11">11</option><option value="12">12</option>
  </select></label>
  <button id="randomBtn">üé≤ Random</button>
  <!-- #5: Scan Board with tooltip -->
  <button id="scanBtn" title="Take a photo of your real Catan board ‚Äî AI vision will auto-detect all tiles and numbers">üì∑ Scan Board</button>
  <button id="clearBtn" class="secondary">Clear</button>
  <label>Top: <select id="topN"><option value="5">5</option><option value="10" selected>10</option><option value="15">15</option><option value="20">20</option></select></label>
  <button id="showAllBtn" class="secondary">üìä All Scores</button>
  <!-- #7: Share button -->
  <button id="shareBtn" class="secondary">üîó Share</button>
  <!-- #8: Settlement planning -->
  <button id="settleBtn" class="secondary settle-mode">üèòÔ∏è Plan Settlements</button>
  <input type="file" id="photoInput" accept="image/*" capture="environment" style="display:none">
</div>

<!-- #6: Legend moved above canvas -->
<div class="legend">
  <div class="legend-item"><div class="legend-dot" style="background:#00ff88;box-shadow:0 0 6px #00ff8866;"></div> Best</div>
  <div class="legend-item"><div class="legend-dot" style="background:#ffdd00;box-shadow:0 0 6px #ffdd0066;"></div> Great</div>
  <div class="legend-item"><div class="legend-dot" style="background:#ff8800;box-shadow:0 0 6px #ff880066;"></div> Good</div>
  <div class="legend-item"><div class="legend-dot" style="background:#ff3355;box-shadow:0 0 6px #ff335566;"></div> Weak</div>
  <div class="legend-item"><div class="legend-dot" style="background:#475569;"></div> No value</div>
  <div class="legend-item"><div class="legend-dot" style="background:#1e40af;"></div> 3:1 Port</div>
  <div class="legend-item"><div class="legend-dot" style="background:#059669;"></div> 2:1 Port</div>
</div>

<div class="canvas-wrap">
  <canvas id="board" width="920" height="620"></canvas>
  <div id="tooltip"></div>
</div>

<!-- #8: Settlement planning panel -->
<div id="settlePanel" class="settle-panel glass">
  <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:10px;">
    <h3>üèòÔ∏è Settlement Planner</h3>
    <button id="resetPicksBtn" class="secondary" style="padding:6px 12px;font-size:0.78em;">Reset Picks</button>
  </div>
  <p style="font-size:0.8em;color:#64748b;margin-bottom:10px;">Click vertices on the board to pick your settlements. The 2nd pick will be scored to complement your 1st.</p>
  <div class="settle-picks" id="settlePicks"></div>
  <div class="settle-combined" id="settleCombined" style="display:none;"></div>
</div>

<!-- #2: Resource Distribution as proper HTML -->
<div id="resourceDist" class="resource-dist glass"></div>

<div id="rarityLedger" class="glass" style="width:100%;max-width:920px;margin:10px auto;padding:14px 18px;border-radius:14px;"></div>

<div id="resourcePool" class="glass" style="width:100%;max-width:920px;margin:10px auto;padding:14px 18px;border-radius:14px;"></div>

<div class="top-list glass" id="topList"></div>

<!-- #9: How it works - more prominent -->
<details class="info-panel glass">
  <summary>üìê How it works <span class="info-teaser">Weighted Pips + Diversity + Ports + Expansion ‚àí Robber Risk</span></summary>
  <div class="info-content">
    <b>Scoring Formula:</b> Score = Weighted Pips + Diversity + Number Spread + Port Bonus ‚àí Robber Risk + Expansion
    <br><br>
    <b>‚öñÔ∏è Weighted Pips:</b> Each tile's pip count √ó <b>dynamic scarcity weight</b>. Weights blend strategic value (ore/wheat for cities) with board-specific rarity ‚Äî resources with fewer tiles and lower pip totals get boosted. Check the Rarity Ledger to see current weights.
    <br><br>
    <b>üìä Resource Probability:</b> Each number has a real probability (e.g. 6/8 = 13.9%, 2/12 = 2.8%). The breakdown shows your expected % chance of getting each resource per roll.
    <br><br>
    <b>üé≤ Diversity Bonus:</b> 3 unique resources = +3, 2 = +1. More types = less trading needed.
    <br><br>
    <b>üéØ Number Spread:</b> 3 different numbers = +2, 2 = +1. Uncorrelated rolls = more consistent income.
    <br><br>
    <b>üö¢ Port Bonus:</b> Matching 2:1 port with that resource = +3, generic 3:1 = +1.5, non-matching 2:1 = +1.
    <br><br>
    <b>üè¥‚Äç‚ò†Ô∏è Robber Risk:</b> If >60% of your pips come from one hex, ‚àí1.5 penalty (robber magnet).
    <br><br>
    <b>üõ§Ô∏è Expansion:</b> Nearby vertices with 4+ pips = better road-building options (up to +3).
    <br><br>
    Click a tile to assign a number, hit Random for a valid layout, or <b>üì∑ Scan Board</b> to
    take a photo of your real Catan board and auto-populate with AI vision.
  </div>
</details>

<script>
let currentMode = '4p';
let ROWS = [3,4,5,4,3];
let TOTAL_TILES = 19;

const BOARD_CONFIGS = {
  '4p': {
    rows: [3,4,5,4,3],
    totalTiles: 19,
    resources: { desert: 1, brick: 3, ore: 3, wood: 4, wheat: 4, sheep: 4 },
    tokens: [0, 2,3,3,4,4,5,5,6,6,8,8,9,9,10,10,11,11,12],
    ports: 9,
    title: "üè† Catan 4P Settlement Optimizer",
    canvasH: 620
  },
  '6p': {
    rows: [3,4,5,6,5,4,3],
    totalTiles: 30,
    resources: { desert: 2, brick: 5, ore: 5, wood: 6, wheat: 6, sheep: 6 },
    tokens: [0,0,2,2,3,3,3,4,4,4,5,5,5,6,6,6,6,8,8,8,8,9,9,9,10,10,10,11,11,11,12,12],
    ports: 11,
    title: "üè† Catan 6P Settlement Optimizer",
    canvasH: 780
  }
};

const RESOURCE_COLORS = {
  brick: '#b5451d', ore: '#6b7d8a', wood: '#1a7a3a', wheat: '#daa520', sheep: '#7ec850', desert: '#c2b280'
};
const RESOURCE_EMOJI = { brick:'üß±', ore:'‚õ∞Ô∏è', wood:'üå≤', wheat:'üåæ', sheep:'üêë' };
const RESOURCE_NAMES = ['brick','ore','wood','wheat','sheep'];
const DOTS = {0:0, 2:1, 3:2, 4:3, 5:4, 6:5, 8:5, 9:4, 10:3, 11:2, 12:1};
const PROB = {0:0, 2:1/36, 3:2/36, 4:3/36, 5:4/36, 6:5/36, 8:5/36, 9:4/36, 10:3/36, 11:2/36, 12:1/36};

const BASE_RESOURCE_WEIGHT = { ore: 1.3, wheat: 1.3, brick: 1.1, wood: 1.1, sheep: 0.9, desert: 0 };

function computeDynamicWeights() {
  const tileCount = {};
  const totalPips = {};
  const RESOURCES = ['ore', 'wheat', 'brick', 'wood', 'sheep'];
  for (const r of RESOURCES) { tileCount[r] = 0; totalPips[r] = 0; }
  for (const t of tiles) {
    if (t.resource !== 'desert' && RESOURCES.includes(t.resource)) {
      tileCount[t.resource]++;
      totalPips[t.resource] += (DOTS[t.number] || 0);
    }
  }
  const anyAssigned = RESOURCES.some(r => totalPips[r] > 0);
  if (!anyAssigned) return BASE_RESOURCE_WEIGHT;
  const allPips = RESOURCES.map(r => totalPips[r]).filter(p => p > 0);
  if (allPips.length === 0) return BASE_RESOURCE_WEIGHT;
  const avgPips = allPips.reduce((a, b) => a + b, 0) / allPips.length;
  const weights = { desert: 0 };
  for (const r of RESOURCES) {
    const pips = totalPips[r] || 0.1;
    const scarcityMult = Math.min(2.0, Math.max(0.6, avgPips / pips));
    weights[r] = Math.round((BASE_RESOURCE_WEIGHT[r] * 0.5 + scarcityMult * 0.5) * 100) / 100;
  }
  return weights;
}

let RESOURCE_WEIGHT = { ...BASE_RESOURCE_WEIGHT };

// === #8: Settlement Planning State ===
let settleMode = false;
let pickedSettlements = []; // array of vertex objects
let optimalPairs = []; // top 10 settlement pairs
let selectedPair = null; // currently selected pair for resource engine

function scoreVertex(v, complementOf) {
  if (!v.isLand || v.adjacentTiles.length === 0) return null;

  let weightedPips = 0;
  let rawPips = 0;
  const resourceCounts = {};
  const resourceProbs = {};
  const uniqueResources = new Set();
  const adjNumbers = [];

  for (const tIdx of v.adjacentTiles) {
    const t = tiles[tIdx];
    if (t.number === 0 || t.resource === 'desert') continue;
    const pips = DOTS[t.number] || 0;
    const prob = PROB[t.number] || 0;
    let w = RESOURCE_WEIGHT[t.resource] || 1;
    
    // #8: Complementary scoring ‚Äî boost uncovered resources, penalize redundant
    if (complementOf) {
      if (complementOf.resources.has(t.resource)) {
        w *= 0.5; // penalize resources already covered
      } else {
        w *= 1.5; // boost uncovered resources
      }
      // Also boost different numbers for probability coverage
      if (complementOf.adjNumbers && complementOf.adjNumbers.includes(t.number)) {
        w *= 0.85; // slight penalty for same numbers
      }
    }
    
    weightedPips += pips * w;
    rawPips += pips;
    uniqueResources.add(t.resource);
    resourceCounts[t.resource] = (resourceCounts[t.resource] || 0) + 1;
    resourceProbs[t.resource] = (resourceProbs[t.resource] || 0) + prob;
    adjNumbers.push(t.number);
  }

  if (rawPips === 0) return null;

  const diversity = uniqueResources.size;
  let diversityBonus = diversity >= 3 ? 3 : diversity === 2 ? 1 : 0;
  
  // Complementary: extra bonus for new resource types
  if (complementOf) {
    let newTypes = 0;
    for (const r of uniqueResources) {
      if (!complementOf.resources.has(r)) newTypes++;
    }
    diversityBonus += newTypes * 0.8;
  }

  const uniqueNumbers = new Set(adjNumbers);
  const spreadBonus = uniqueNumbers.size >= 3 ? 2 : uniqueNumbers.size === 2 ? 1 : 0;

  let portBonus = 0;
  if (v.portAccess) {
    if (v.portAccess.type === 'resource' && uniqueResources.has(v.portAccess.resource)) {
      portBonus = 3;
    } else if (v.portAccess.type === 'resource') {
      portBonus = 1;
    } else {
      portBonus = 1.5;
    }
  }

  let robberPenalty = 0;
  if (adjNumbers.length > 1) {
    const maxSinglePip = Math.max(...v.adjacentTiles.map(i => DOTS[tiles[i].number] || 0));
    if (rawPips > 0 && maxSinglePip / rawPips > 0.6) {
      robberPenalty = 1.5;
    }
  }

  let expansionScore = 0;
  const ROAD_DIST = HEX_R * Math.sqrt(3) * 1.2;
  for (const other of vertices) {
    if (other === v || !other.isLand || other.dots === 0) continue;
    const d = Math.hypot(v.x - other.x, v.y - other.y);
    if (d < ROAD_DIST && other.dots >= 4) {
      expansionScore += 0.5;
    }
  }
  expansionScore = Math.min(expansionScore, 3);

  const totalScore = weightedPips + diversityBonus + spreadBonus + portBonus - robberPenalty + expansionScore;

  return {
    totalScore: Math.round(totalScore * 10) / 10,
    weightedPips: Math.round(weightedPips * 10) / 10,
    rawPips,
    diversity,
    diversityBonus,
    spreadBonus,
    portBonus,
    robberPenalty,
    expansionScore: Math.round(expansionScore * 10) / 10,
    resources: uniqueResources,
    resourceProbs,
    resourceCounts,
    adjNumbers
  };
}

// Check if two vertices are valid settlement pair (respect distance rule)
function isValidSettlementPair(v1, v2) {
  // Build edges array if not exists
  if (!window.edges) {
    window.edges = [];
    const SNAP = 3;
    function snapKey(x, y) {
      const sx = Math.round(x / SNAP) * SNAP;
      const sy = Math.round(y / SNAP) * SNAP;
      return `${sx},${sy}`;
    }
    
    // Create edges between adjacent vertices on the hex grid
    for (let t = 0; t < tiles.length; t++) {
      const tile = tiles[t];
      for (let i = 0; i < 6; i++) {
        const c1 = hexCorner(tile.cx, tile.cy, HEX_R, i);
        const c2 = hexCorner(tile.cx, tile.cy, HEX_R, (i + 1) % 6);
        const key1 = snapKey(c1.x, c1.y);
        const key2 = snapKey(c2.x, c2.y);
        
        // Find vertex indices
        const v1Idx = vertices.findIndex(v => v.key === key1);
        const v2Idx = vertices.findIndex(v => v.key === key2);
        
        if (v1Idx !== -1 && v2Idx !== -1) {
          window.edges.push([v1Idx, v2Idx]);
        }
      }
    }
  }
  
  const v1Idx = vertices.indexOf(v1);
  const v2Idx = vertices.indexOf(v2);
  if (v1Idx === -1 || v2Idx === -1) return false;
  
  // Check if vertices are connected by an edge
  for (const [a, b] of window.edges) {
    if ((a === v1Idx && b === v2Idx) || (a === v2Idx && b === v1Idx)) {
      return false; // Adjacent vertices, invalid
    }
  }
  
  return true;
}

// Score a settlement pair with synergy bonuses
function scorePair(v1, v2) {
  const s1 = scoreVertex(v1, null);
  const s2 = scoreVertex(v2, null);
  if (!s1 || !s2) return null;
  
  // Combined resources and numbers
  const combinedResources = new Set([...s1.resources, ...s2.resources]);
  const combinedNumbers = new Set([...s1.adjNumbers, ...s2.adjNumbers]);
  
  // Base score sum
  const baseScore = s1.totalScore + s2.totalScore;
  
  // Resource diversity bonus (big bonus for 5 unique resources)
  let diversityBonus = 0;
  const uniqueCount = combinedResources.size;
  if (uniqueCount === 5) diversityBonus = 8;
  else if (uniqueCount === 4) diversityBonus = 4;
  else if (uniqueCount === 3) diversityBonus = 2;
  
  // Number spread coverage bonus
  let spreadBonus = 0;
  const numberCount = combinedNumbers.size;
  if (numberCount >= 5) spreadBonus = 3;
  else if (numberCount >= 4) spreadBonus = 2;
  else if (numberCount >= 3) spreadBonus = 1;
  
  // Port synergy bonus
  let portBonus = 0;
  if (v1.portAccess && combinedResources.has(v1.portAccess.resource)) portBonus += 2;
  if (v2.portAccess && combinedResources.has(v2.portAccess.resource)) portBonus += 2;
  if (v1.portAccess && v1.portAccess.type === 'generic') portBonus += 1;
  if (v2.portAccess && v2.portAccess.type === 'generic') portBonus += 1;
  
  // Overlap penalty (same resources/numbers reduce efficiency)
  let overlapPenalty = 0;
  const resourceOverlap = s1.resources.size + s2.resources.size - combinedResources.size;
  const numberOverlap = s1.adjNumbers.length + s2.adjNumbers.length - combinedNumbers.size;
  overlapPenalty = resourceOverlap * 0.5 + numberOverlap * 0.3;
  
  const totalScore = baseScore + diversityBonus + spreadBonus + portBonus - overlapPenalty;
  
  return {
    v1, v2,
    totalScore: Math.round(totalScore * 10) / 10,
    baseScore: Math.round(baseScore * 10) / 10,
    diversityBonus,
    spreadBonus,
    portBonus,
    overlapPenalty: Math.round(overlapPenalty * 10) / 10,
    combinedResources,
    combinedNumbers,
    resourceCount: combinedResources.size,
    numberCount: combinedNumbers.size
  };
}

// Find top 10 optimal settlement pairs
function findOptimalPairs() {
  const validVertices = vertices.filter(v => v.isLand && v.score && v.score.totalScore > 0);
  const pairs = [];
  
  // Brute force all valid pairs
  for (let i = 0; i < validVertices.length; i++) {
    for (let j = i + 1; j < validVertices.length; j++) {
      const v1 = validVertices[i];
      const v2 = validVertices[j];
      
      if (isValidSettlementPair(v1, v2)) {
        const pairScore = scorePair(v1, v2);
        if (pairScore) {
          pairs.push(pairScore);
        }
      }
    }
  }
  
  // Sort by total score and take top 10
  pairs.sort((a, b) => b.totalScore - a.totalScore);
  optimalPairs = pairs.slice(0, 10);
}

// Calculate resource engine analysis for a settlement pair
function calculateResourceEngine(v1, v2) {
  const resourceIncome = {
    brick: 0, ore: 0, wood: 0, wheat: 0, sheep: 0
  };
  
  // Calculate expected income per turn from both settlements
  for (const v of [v1, v2]) {
    for (const tIdx of v.adjacentTiles) {
      const t = tiles[tIdx];
      if (t.number > 0 && t.resource !== 'desert' && resourceIncome.hasOwnProperty(t.resource)) {
        resourceIncome[t.resource] += PROB[t.number];
      }
    }
  }
  
  // Building requirements
  const buildings = {
    road: { brick: 1, wood: 1 },
    settlement: { brick: 1, wood: 1, wheat: 1, sheep: 1 },
    city: { ore: 3, wheat: 2 },
    devCard: { ore: 1, wheat: 1, sheep: 1 }
  };
  
  // Calculate affordability
  const affordability = {};
  
  for (const [building, cost] of Object.entries(buildings)) {
    if (building === 'city') {
      // For city: expected turns to accumulate (different calculation)
      const orePerTurn = resourceIncome.ore;
      const wheatPerTurn = resourceIncome.wheat;
      
      if (orePerTurn > 0 && wheatPerTurn > 0) {
        // Expected turns = max(turns_for_ore, turns_for_wheat)
        const turnsForOre = 3 / orePerTurn;
        const turnsForWheat = 2 / wheatPerTurn;
        affordability[building] = Math.max(turnsForOre, turnsForWheat);
      } else {
        affordability[building] = Infinity;
      }
    } else {
      // For other buildings: probability of getting all required resources in one turn cycle
      let prob = 1;
      for (const [resource, amount] of Object.entries(cost)) {
        const income = resourceIncome[resource];
        if (income === 0) {
          prob = 0;
          break;
        }
        // Probability of getting at least 'amount' of resource in one turn
        // Using Poisson approximation for multiple resources
        const expectedIncome = income;
        if (amount === 1) {
          prob *= (1 - Math.exp(-expectedIncome)); // P(X >= 1) = 1 - P(X = 0)
        } else {
          // For multiple resources, simple approximation
          prob *= Math.min(expectedIncome / amount, 1);
        }
      }
      affordability[building] = prob;
    }
  }
  
  return { resourceIncome, affordability };
}

function generateRandomNumbers() {
  const config = BOARD_CONFIGS[currentMode];
  const nums = [...config.tokens];
  for (let i = nums.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [nums[i], nums[j]] = [nums[j], nums[i]];
  }
  return nums;
}

function generateRandomResources() {
  const config = BOARD_CONFIGS[currentMode];
  const res = [];
  for (const [type, count] of Object.entries(config.resources)) {
    res.push(...Array(count).fill(type));
  }
  for (let i = res.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [res[i], res[j]] = [res[j], res[i]];
  }
  return res;
}

let tiles = [];
let oceanTiles = [];
let ports = [];
let vertices = [];

const canvas = document.getElementById('board');
const ctx = canvas.getContext('2d');
const tooltip = document.getElementById('tooltip');

const HEX_R = 40;
const HEX_H = HEX_R * Math.sqrt(3);
let CX = canvas.width / 2;
let CY = canvas.height / 2;

function hexCorner(cx, cy, r, i) {
  const angle = Math.PI / 180 * (60 * i - 30);
  return { x: cx + r * Math.cos(angle), y: cy + r * Math.sin(angle) };
}

function resizeCanvas() {
  const config = BOARD_CONFIGS[currentMode];
  canvas.height = config.canvasH;
  CX = canvas.width / 2;
  CY = canvas.height / 2;
}

function switchMode(newMode) {
  if (newMode === currentMode && tiles.length > 0) return;
  currentMode = newMode;
  const config = BOARD_CONFIGS[currentMode];
  ROWS = [...config.rows];
  TOTAL_TILES = config.totalTiles;
  document.getElementById('mainTitle').textContent = config.title;
  document.getElementById('mode4p').classList.toggle('active', newMode === '4p');
  document.getElementById('mode6p').classList.toggle('active', newMode === '6p');
  resizeCanvas();
  buildBoard();
  drawBoard();
}

function buildBoard() {
  tiles = [];
  oceanTiles = [];
  ports = [];
  
  const vSpacing = 1.5 * HEX_R;
  const hSpacing = Math.sqrt(3) * HEX_R;
  const totalHeight = (ROWS.length - 1) * vSpacing;
  const topY = CY - totalHeight / 2;

  let tileIdx = 0;
  for (let r = 0; r < ROWS.length; r++) {
    const count = ROWS[r];
    const y = topY + r * vSpacing;
    const rowWidth = (count - 1) * hSpacing;
    const startX = CX - rowWidth / 2;
    for (let c = 0; c < count; c++) {
      tiles.push({
        cx: startX + c * hSpacing,
        cy: y,
        number: 0,
        resource: 'desert',
        row: r, col: c, idx: tileIdx++
      });
    }
  }
  
  buildOceanAndPorts();
  buildVertices();
}

function buildOceanAndPorts() {
  const hSpacing = Math.sqrt(3) * HEX_R;
  const vSpacing = 1.5 * HEX_R;
  
  function isLandAt(x, y) {
    return tiles.some(t => Math.hypot(x - t.cx, y - t.cy) < HEX_R * 0.5);
  }
  
  const seen = new Set();
  const oceanPositions = [];
  const neighborOffsets = [
    [-hSpacing, 0], [hSpacing, 0],
    [-hSpacing/2, -vSpacing], [hSpacing/2, -vSpacing],
    [-hSpacing/2, vSpacing], [hSpacing/2, vSpacing]
  ];
  
  for (const tile of tiles) {
    for (const [dx, dy] of neighborOffsets) {
      const nx = tile.cx + dx;
      const ny = tile.cy + dy;
      const key = Math.round(nx) + ',' + Math.round(ny);
      if (seen.has(key)) continue;
      seen.add(key);
      if (!isLandAt(nx, ny)) {
        oceanPositions.push({ x: nx, y: ny });
      }
    }
  }
  
  oceanTiles = oceanPositions.map((pos, i) => ({
    cx: pos.x, cy: pos.y, side: 'ocean', idx: i
  }));
  
  generatePorts();
}

function getCoastalEdges() {
  const hSpacing = Math.sqrt(3) * HEX_R;
  const edges = [];
  
  for (const tile of tiles) {
    for (let i = 0; i < 6; i++) {
      const c1 = hexCorner(tile.cx, tile.cy, HEX_R, i);
      const c2 = hexCorner(tile.cx, tile.cy, HEX_R, (i + 1) % 6);
      const midX = (c1.x + c2.x) / 2;
      const midY = (c1.y + c2.y) / 2;
      
      const isCoastal = !tiles.some(other => {
        if (other === tile) return false;
        const d = Math.hypot(other.cx - tile.cx, other.cy - tile.cy);
        if (d > hSpacing * 1.1) return false;
        for (let j = 0; j < 6; j++) {
          const oc1 = hexCorner(other.cx, other.cy, HEX_R, j);
          const oc2 = hexCorner(other.cx, other.cy, HEX_R, (j + 1) % 6);
          const omx = (oc1.x + oc2.x) / 2;
          const omy = (oc1.y + oc2.y) / 2;
          if (Math.hypot(midX - omx, midY - omy) < 5) return true;
        }
        return false;
      });
      
      if (isCoastal) {
        const angle = Math.atan2(midY - CY, midX - CX);
        edges.push({ midX, midY, v1: c1, v2: c2, angle, tileIdx: tile.idx, edgeIdx: i });
      }
    }
  }
  
  edges.sort((a, b) => {
    const aa = (a.angle + Math.PI * 2.5 + Math.PI / 2) % (Math.PI * 2);
    const bb = (b.angle + Math.PI * 2.5 + Math.PI / 2) % (Math.PI * 2);
    return aa - bb;
  });
  
  return edges;
}

function generatePorts() {
  const config = BOARD_CONFIGS[currentMode];
  ports = [];
  
  const coastalEdges = getCoastalEdges();
  const totalEdges = coastalEdges.length;
  
  let portTypes;
  if (currentMode === '4p') {
    portTypes = [
      { type: 'generic', resource: null },
      { type: 'resource', resource: 'wheat' },
      { type: 'resource', resource: 'ore' },
      { type: 'generic', resource: null },
      { type: 'resource', resource: 'sheep' },
      { type: 'generic', resource: null },
      { type: 'generic', resource: null },
      { type: 'resource', resource: 'brick' },
      { type: 'resource', resource: 'wood' },
    ];
  } else {
    portTypes = [
      { type: 'generic', resource: null },
      { type: 'resource', resource: 'wheat' },
      { type: 'resource', resource: 'ore' },
      { type: 'generic', resource: null },
      { type: 'resource', resource: 'sheep' },
      { type: 'generic', resource: null },
      { type: 'resource', resource: 'brick' },
      { type: 'generic', resource: null },
      { type: 'resource', resource: 'wood' },
      { type: 'generic', resource: null },
      { type: 'resource', resource: 'wheat' },
    ];
  }
  
  const numPorts = portTypes.length;
  const step = totalEdges / numPorts;
  
  const usedOceanTiles = new Set();
  for (let i = 0; i < numPorts; i++) {
    const edgeIndex = Math.round(i * step) % totalEdges;
    const edge = coastalEdges[edgeIndex];
    
    const sorted = [...oceanTiles].map((ot, idx) => ({
      idx, cx: ot.cx, cy: ot.cy,
      d: Math.hypot(ot.cx - edge.midX, ot.cy - edge.midY)
    })).sort((a, b) => a.d - b.d);
    let chosen = sorted[0];
    for (const candidate of sorted) {
      if (!usedOceanTiles.has(candidate.idx)) { chosen = candidate; break; }
    }
    usedOceanTiles.add(chosen.idx);
    
    // #12: Push port position slightly outward from board center
    const dx = chosen.cx - CX;
    const dy = chosen.cy - CY;
    const dist = Math.hypot(dx, dy);
    const pushFactor = 8; // pixels outward
    const px = dist > 0 ? chosen.cx + (dx / dist) * pushFactor : chosen.cx;
    const py = dist > 0 ? chosen.cy + (dy / dist) * pushFactor : chosen.cy;
    
    ports.push({
      cx: px, cy: py,
      type: portTypes[i].type,
      resource: portTypes[i].resource,
      ratio: portTypes[i].type === 'generic' ? '3:1' : '2:1',
      vertex1: edge.v1,
      vertex2: edge.v2,
      edgeMid: { x: edge.midX, y: edge.midY }
    });
  }
}

function buildVertices() {
  vertices = [];
  const vMap = new Map();
  const SNAP = 3;
  function snapKey(x, y) {
    const sx = Math.round(x / SNAP) * SNAP;
    const sy = Math.round(y / SNAP) * SNAP;
    return `${sx},${sy}`;
  }
  
  for (let t = 0; t < tiles.length; t++) {
    const tile = tiles[t];
    for (let i = 0; i < 6; i++) {
      const corner = hexCorner(tile.cx, tile.cy, HEX_R, i);
      const key = snapKey(corner.x, corner.y);
      if (!vMap.has(key)) {
        const vIdx = vertices.length;
        vertices.push({ x: corner.x, y: corner.y, adjacentTiles: [t], key, isLand: true });
        vMap.set(key, vIdx);
      } else {
        const vIdx = vMap.get(key);
        if (!vertices[vIdx].adjacentTiles.includes(t)) {
          vertices[vIdx].adjacentTiles.push(t);
        }
      }
    }
  }
  
  for (let t = 0; t < oceanTiles.length; t++) {
    const tile = oceanTiles[t];
    for (let i = 0; i < 6; i++) {
      const corner = hexCorner(tile.cx, tile.cy, HEX_R, i);
      const key = snapKey(corner.x, corner.y);
      if (!vMap.has(key)) {
        const vIdx = vertices.length;
        vertices.push({ x: corner.x, y: corner.y, adjacentTiles: [], key, isLand: false, oceanTiles: [t] });
        vMap.set(key, vIdx);
      } else {
        const vIdx = vMap.get(key);
        if (!vertices[vIdx].oceanTiles) vertices[vIdx].oceanTiles = [];
        if (!vertices[vIdx].oceanTiles.includes(t)) {
          vertices[vIdx].oceanTiles.push(t);
        }
      }
    }
  }
}

function computeVertexValues() {
  RESOURCE_WEIGHT = computeDynamicWeights();
  
  // First pass: compute dots for expansion scoring
  for (const v of vertices) {
    let totalDots = 0;
    for (const tIdx of v.adjacentTiles) {
      totalDots += DOTS[tiles[tIdx].number] || 0;
    }
    v.dots = totalDots;
  }
  
  // Determine complement source for settlement mode
  const complementOf = (settleMode && pickedSettlements.length === 1) ? pickedSettlements[0].score : null;
  
  for (const v of vertices) {
    const resources = new Set();
    for (const tIdx of v.adjacentTiles) {
      const t = tiles[tIdx];
      if (t.resource !== 'desert' && t.number > 0) resources.add(t.resource);
    }
    v.resources = resources;
    
    v.portAccess = null;
    for (const port of ports) {
      if (port.vertex1 && port.vertex2) {
        const d1 = Math.hypot(v.x - port.vertex1.x, v.y - port.vertex1.y);
        const d2 = Math.hypot(v.x - port.vertex2.x, v.y - port.vertex2.y);
        if (d1 < 5 || d2 < 5) {
          v.portAccess = port;
          break;
        }
      }
    }

    v.score = scoreVertex(v, complementOf);
  }
}

function randomizeBoard() {
  const numbers = generateRandomNumbers();
  const resources = generateRandomResources();
  for (let i = 0; i < tiles.length; i++) {
    tiles[i].resource = resources[i];
    tiles[i].number = 0;
  }
  const numberedTokens = numbers.filter(n => n > 0);
  let ni = 0;
  for (let i = 0; i < tiles.length; i++) {
    if (tiles[i].resource === 'desert') {
      tiles[i].number = 0;
    } else {
      tiles[i].number = numberedTokens[ni++] || 0;
    }
  }
}

// #2: Resource Distribution as HTML element
function updateResourceDist() {
  const el = document.getElementById('resourceDist');
  const tileCount = {};
  const totalPips = {};
  for (const r of RESOURCE_NAMES) { tileCount[r] = 0; totalPips[r] = 0; }
  for (const t of tiles) {
    if (t.resource !== 'desert' && RESOURCE_NAMES.includes(t.resource)) {
      tileCount[t.resource]++;
      totalPips[t.resource] += (DOTS[t.number] || 0);
    }
  }
  const anyAssigned = RESOURCE_NAMES.some(r => tileCount[r] > 0);
  if (!anyAssigned) { el.innerHTML = ''; return; }
  
  const maxPips = Math.max(...Object.values(totalPips), 1);
  const sorted = [...RESOURCE_NAMES].sort((a, b) => totalPips[b] - totalPips[a]);
  
  let html = '<h3>üìä Resource Distribution</h3>';
  for (const r of sorted) {
    const barW = Math.max(2, (totalPips[r] / maxPips) * 100);
    html += `<div class="res-row">
      <span class="res-label">${RESOURCE_EMOJI[r]} ${r}</span>
      <div class="res-bar-wrap"><div class="res-bar" style="width:${barW}%;background:${RESOURCE_COLORS[r]};"></div></div>
      <span class="res-stat">${tileCount[r]}√ó ${totalPips[r]}‚ô¶</span>
      <span class="res-weight">${RESOURCE_WEIGHT[r].toFixed(2)}√ó</span>
    </div>`;
  }
  el.innerHTML = html;
}

function drawBoard() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  const grad = ctx.createRadialGradient(CX, CY, 0, CX, CY, canvas.width * 0.55);
  grad.addColorStop(0, '#0f2847');
  grad.addColorStop(0.6, '#0a1a35');
  grad.addColorStop(1, '#060d1f');
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  for (const oceanTile of oceanTiles) drawOceanHex(oceanTile);
  for (const port of ports) drawPort(port);
  for (const tile of tiles) drawHex(tile);

  computeVertexValues();
  const scored = vertices.filter(v => v.isLand && v.score);
  const maxScore = Math.max(...scored.map(v => v.score.totalScore), 1);
  const sorted = [...scored].sort((a, b) => b.score.totalScore - a.score.totalScore);
  const topN = parseInt(document.getElementById('topN').value);
  const topSet = new Set(sorted.slice(0, topN));

  for (const v of scored) {
    const ratio = v.score.totalScore / maxScore;
    const rank = sorted.indexOf(v);
    let color, radius, glowColor;
    
    // Check if this vertex is a picked settlement or part of selected pair
    const isPicked = pickedSettlements.includes(v) || (selectedPair && (selectedPair.v1 === v || selectedPair.v2 === v));

    if (isPicked) {
      color = '#10b981'; radius = 14; glowColor = 'rgba(16,185,129,0.6)';
    } else if (topSet.has(v) && rank < Math.ceil(topN * 0.3)) {
      color = '#00ff88'; radius = 10; glowColor = 'rgba(0,255,136,0.5)';
    } else if (topSet.has(v) && rank < Math.ceil(topN * 0.6)) {
      color = '#ffdd00'; radius = 9; glowColor = 'rgba(255,221,0,0.4)';
    } else if (topSet.has(v)) {
      color = '#ff8800'; radius = 8; glowColor = 'rgba(255,136,0,0.35)';
    } else if (showAllScores) {
      if (ratio > 0.7) { color = '#66bb6a'; }
      else if (ratio > 0.5) { color = '#42a5f5'; }
      else if (ratio > 0.3) { color = '#ab47bc'; }
      else { color = '#78909c'; }
      radius = 9;
      glowColor = color + '60';
    } else {
      color = `rgba(255,255,255,${0.12 + ratio * 0.3})`;
      radius = 4 + ratio * 3;
      glowColor = null;
    }

    if (glowColor) {
      ctx.save();
      ctx.shadowColor = glowColor;
      ctx.shadowBlur = isPicked ? 18 : 12;
      ctx.beginPath();
      ctx.arc(v.x, v.y, radius, 0, Math.PI * 2);
      ctx.fillStyle = color;
      ctx.fill();
      ctx.restore();

      ctx.beginPath();
      ctx.arc(v.x, v.y, radius, 0, Math.PI * 2);
      ctx.strokeStyle = isPicked ? 'white' : 'rgba(255,255,255,0.6)';
      ctx.lineWidth = isPicked ? 2.5 : 1.5;
      ctx.stroke();

      // Draw house icon for picked settlements
      if (isPicked) {
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 10px Inter, sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('üè†', v.x, v.y);
      } else {
        ctx.fillStyle = '#000';
        ctx.font = 'bold 7px Inter, sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(v.score.totalScore.toFixed(0), v.x, v.y);
      }
    } else {
      ctx.beginPath();
      ctx.arc(v.x, v.y, radius, 0, Math.PI * 2);
      ctx.fillStyle = color;
      ctx.fill();
    }

    if (v.portAccess && !isPicked) {
      const portColor = v.portAccess.type === 'generic' ? '#1e40af' : '#059669';
      ctx.beginPath();
      ctx.arc(v.x - radius - 3, v.y - radius - 3, 3, 0, Math.PI * 2);
      ctx.fillStyle = portColor;
      ctx.fill();
      ctx.strokeStyle = 'white';
      ctx.lineWidth = 1;
      ctx.stroke();
    }
  }

  updateTopList(sorted, topN);
  updateResourceDist();
  updateResourcePool();
  updateRarityLedger();
  updateSettlePanel();
}

function updateResourcePool() {
  const el = document.getElementById('resourcePool');
  const pool = {};
  for (const r of RESOURCE_NAMES) pool[r] = 0;
  for (const t of tiles) {
    if (t.resource !== 'desert' && t.number > 0 && pool.hasOwnProperty(t.resource)) {
      pool[t.resource] += (DOTS[t.number] || 0) / 36;
    }
  }
  const maxProb = Math.max(...Object.values(pool), 0.001);
  const labels = { brick:'üß± Brick', ore:'‚õ∞Ô∏è Ore', wood:'üå≤ Wood', wheat:'üåæ Wheat', sheep:'üêë Sheep' };
  let html = '<div style="font:600 0.92em Inter,sans-serif;color:#e2e8f0;margin-bottom:10px;">üìä Resource Probability Pool</div>';
  for (const r of RESOURCE_NAMES) {
    const pct = (pool[r] * 100).toFixed(1);
    const barW = Math.max(1, (pool[r] / maxProb) * 100);
    html += `<div style="display:flex;align-items:center;gap:8px;margin:5px 0;font:500 0.8em Inter,sans-serif;color:#cbd5e1;">
      <span style="width:75px;text-align:right;">${labels[r]}</span>
      <div style="flex:1;height:14px;background:rgba(255,255,255,0.06);border-radius:7px;overflow:hidden;">
        <div style="width:${barW}%;height:100%;background:${RESOURCE_COLORS[r]};border-radius:7px;transition:width 0.3s;"></div>
      </div>
      <span style="width:45px;font-variant-numeric:tabular-nums;">${pct}%</span>
    </div>`;
  }
  el.innerHTML = html;
}

function updateRarityLedger() {
  const el = document.getElementById('rarityLedger');
  const tileCount = {};
  const totalPips = {};
  for (const r of RESOURCE_NAMES) { tileCount[r] = 0; totalPips[r] = 0; }
  for (const t of tiles) {
    if (t.resource !== 'desert' && RESOURCE_NAMES.includes(t.resource)) {
      tileCount[t.resource]++;
      totalPips[t.resource] += (DOTS[t.number] || 0);
    }
  }
  const anyAssigned = RESOURCE_NAMES.some(r => tileCount[r] > 0);
  if (!anyAssigned) {
    el.innerHTML = '<div style="font:600 0.92em Inter,sans-serif;color:#e2e8f0;margin-bottom:6px;">üìã Resource Rarity</div><div style="font:400 0.8em Inter,sans-serif;color:#64748b;">Assign numbers to see rarity breakdown</div>';
    return;
  }
  const maxPips = Math.max(...Object.values(totalPips), 1);
  const labels = { brick:'üß± Brick', ore:'‚õ∞Ô∏è Ore', wood:'üå≤ Wood', wheat:'üåæ Wheat', sheep:'üêë Sheep' };
  const sorted = [...RESOURCE_NAMES].sort((a, b) => totalPips[a] - totalPips[b]);
  let html = '<div style="font:600 0.92em Inter,sans-serif;color:#e2e8f0;margin-bottom:10px;">üìã Resource Rarity <span style="font-weight:400;font-size:0.8em;color:#64748b;">‚Äî rarest ‚Üí most common</span></div>';
  for (const r of sorted) {
    const pips = totalPips[r];
    const count = tileCount[r];
    const barW = Math.max(2, (pips / maxPips) * 100);
    let tag, tagColor;
    const pipRatio = pips / maxPips;
    if (pipRatio <= 0.4) { tag = 'RARE'; tagColor = '#ef4444'; }
    else if (pipRatio <= 0.65) { tag = 'SCARCE'; tagColor = '#f59e0b'; }
    else if (pipRatio <= 0.85) { tag = 'COMMON'; tagColor = '#3b82f6'; }
    else { tag = 'ABUNDANT'; tagColor = '#22c55e'; }
    html += `<div style="display:flex;align-items:center;gap:8px;margin:6px 0;font:500 0.8em Inter,sans-serif;color:#cbd5e1;">
      <span style="width:75px;text-align:right;">${labels[r]}</span>
      <div style="flex:1;height:16px;background:rgba(255,255,255,0.06);border-radius:8px;overflow:hidden;">
        <div style="width:${barW}%;height:100%;background:${RESOURCE_COLORS[r]};border-radius:8px;transition:width 0.3s;"></div>
      </div>
      <span style="width:30px;text-align:center;font-variant-numeric:tabular-nums;">${count}√ó</span>
      <span style="width:40px;text-align:center;font-variant-numeric:tabular-nums;">${pips}‚ô¶</span>
      <span style="width:65px;text-align:center;font-size:0.75em;font-weight:700;color:${tagColor};background:${tagColor}18;padding:2px 6px;border-radius:4px;">${tag}</span>
      <span style="width:40px;text-align:center;font-size:0.72em;color:#94a3b8;">${RESOURCE_WEIGHT[r].toFixed(2)}√ó</span>
    </div>`;
  }
  el.innerHTML = html;
}

function drawOceanHex(oceanTile) {
  const corners = [];
  for (let i = 0; i < 6; i++) corners.push(hexCorner(oceanTile.cx, oceanTile.cy, HEX_R - 1, i));
  ctx.beginPath();
  ctx.moveTo(corners[0].x, corners[0].y);
  for (let i = 1; i < 6; i++) ctx.lineTo(corners[i].x, corners[i].y);
  ctx.closePath();
  const oceanGrad = ctx.createRadialGradient(oceanTile.cx - 10, oceanTile.cy - 10, 0, oceanTile.cx, oceanTile.cy, HEX_R);
  oceanGrad.addColorStop(0, '#1e3a8a');
  oceanGrad.addColorStop(0.5, '#1e40af');
  oceanGrad.addColorStop(1, '#1d4ed8');
  ctx.fillStyle = oceanGrad;
  ctx.fill();
  const waveGrad = ctx.createLinearGradient(
    oceanTile.cx - HEX_R, oceanTile.cy - HEX_R,
    oceanTile.cx + HEX_R, oceanTile.cy + HEX_R
  );
  waveGrad.addColorStop(0, 'rgba(255,255,255,0.05)');
  waveGrad.addColorStop(0.3, 'rgba(255,255,255,0.15)');
  waveGrad.addColorStop(0.7, 'rgba(255,255,255,0.05)');
  waveGrad.addColorStop(1, 'rgba(255,255,255,0.1)');
  ctx.fillStyle = waveGrad;
  ctx.fill();
  ctx.strokeStyle = 'rgba(30,58,138,0.8)';
  ctx.lineWidth = 1;
  ctx.stroke();
}

// #12: Improved port drawing ‚Äî bigger circle, pushed outward, better text
function drawPort(port) {
  if (port.vertex1 && port.vertex2) {
    [port.vertex1, port.vertex2].forEach(v => {
      ctx.beginPath();
      ctx.moveTo(port.cx, port.cy);
      ctx.lineTo(v.x, v.y);
      ctx.strokeStyle = 'rgba(255,255,255,0.3)';
      ctx.lineWidth = 1.5;
      ctx.setLineDash([4, 3]);
      ctx.stroke();
      ctx.setLineDash([]);
    });
  }

  const PORT_RESOURCE_COLORS = { brick: '#b5451d', ore: '#6b7d8a', wood: '#1a7a3a', wheat: '#daa520', sheep: '#7ec850' };
  const bgColor = port.type === 'generic' ? '#1e40af' : (PORT_RESOURCE_COLORS[port.resource] || '#059669');
  
  // Bigger port circle with shadow
  ctx.save();
  ctx.shadowColor = 'rgba(0,0,0,0.4)';
  ctx.shadowBlur = 4;
  ctx.beginPath();
  ctx.arc(port.cx, port.cy, 16, 0, Math.PI * 2);
  ctx.fillStyle = bgColor;
  ctx.fill();
  ctx.restore();
  
  ctx.beginPath();
  ctx.arc(port.cx, port.cy, 16, 0, Math.PI * 2);
  ctx.strokeStyle = 'rgba(255,255,255,0.8)';
  ctx.lineWidth = 1.5;
  ctx.stroke();

  ctx.fillStyle = 'white';
  ctx.font = 'bold 9px Inter, sans-serif';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(port.ratio, port.cx, port.cy - 2);

  if (port.type === 'resource' && port.resource) {
    ctx.font = 'bold 7px Inter, sans-serif';
    ctx.fillText(port.resource.substring(0, 3).toUpperCase(), port.cx, port.cy + 8);
  }
}

function drawHex(tile) {
  const corners = [];
  for (let i = 0; i < 6; i++) corners.push(hexCorner(tile.cx, tile.cy, HEX_R - 2, i));
  ctx.beginPath();
  ctx.moveTo(corners[0].x, corners[0].y);
  for (let i = 1; i < 6; i++) ctx.lineTo(corners[i].x, corners[i].y);
  ctx.closePath();
  const baseColor = RESOURCE_COLORS[tile.resource] || '#555';
  ctx.fillStyle = baseColor;
  ctx.fill();
  const innerGrad = ctx.createRadialGradient(tile.cx - 8, tile.cy - 8, 0, tile.cx, tile.cy, HEX_R);
  innerGrad.addColorStop(0, 'rgba(255,255,255,0.1)');
  innerGrad.addColorStop(1, 'rgba(0,0,0,0.15)');
  ctx.fillStyle = innerGrad;
  ctx.fill();
  ctx.strokeStyle = 'rgba(0,0,0,0.4)';
  ctx.lineWidth = 2;
  ctx.stroke();
  const innerCorners = [];
  for (let i = 0; i < 6; i++) innerCorners.push(hexCorner(tile.cx, tile.cy, HEX_R - 4, i));
  ctx.beginPath();
  ctx.moveTo(innerCorners[0].x, innerCorners[0].y);
  for (let i = 1; i < 6; i++) ctx.lineTo(innerCorners[i].x, innerCorners[i].y);
  ctx.closePath();
  ctx.strokeStyle = 'rgba(255,255,255,0.08)';
  ctx.lineWidth = 1;
  ctx.stroke();
  if (tile.number > 0) {
    const isHot = tile.number === 6 || tile.number === 8;
    ctx.save();
    ctx.shadowColor = 'rgba(0,0,0,0.4)';
    ctx.shadowBlur = 6;
    ctx.shadowOffsetY = 2;
    ctx.beginPath();
    ctx.arc(tile.cx, tile.cy, 15, 0, Math.PI * 2);
    ctx.fillStyle = '#f5f0dc';
    ctx.fill();
    ctx.restore();
    ctx.beginPath();
    ctx.arc(tile.cx, tile.cy, 15, 0, Math.PI * 2);
    ctx.strokeStyle = isHot ? 'rgba(204,0,0,0.3)' : 'rgba(0,0,0,0.15)';
    ctx.lineWidth = 1.5;
    ctx.stroke();
    ctx.fillStyle = isHot ? '#cc0000' : '#1a1a2e';
    ctx.font = isHot ? 'bold 13px Inter, sans-serif' : '600 12px Inter, sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(tile.number, tile.cx, tile.cy - 1);
    const d = DOTS[tile.number];
    const dotY = tile.cy + 9;
    const dotStart = tile.cx - (d - 1) * 2.5;
    ctx.fillStyle = isHot ? '#cc0000' : '#888';
    for (let i = 0; i < d; i++) {
      ctx.beginPath();
      ctx.arc(dotStart + i * 5, dotY, 1.5, 0, Math.PI * 2);
      ctx.fill();
    }
  }
  ctx.fillStyle = 'rgba(255,255,255,0.65)';
  ctx.font = '500 7px Inter, sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText(tile.resource, tile.cx, tile.cy + (tile.number > 0 ? 20 : 4));
}

// #3: Redesigned top list with cards
function updateTopList(sorted, topN) {
  const el = document.getElementById('topList');
  const shown = sorted.slice(0, topN);
  if (shown.length === 0) {
    el.innerHTML = '<h3>Top Settlement Spots</h3><p>Assign numbers to tiles first (click tiles or hit Random)</p>';
    return;
  }
  
  const label = (settleMode && pickedSettlements.length === 1) ? `Best Complementary 2nd Settlements` : `Top ${topN} Settlement Spots`;
  let html = `<h3>${label}</h3>`;
  
  for (let i = 0; i < shown.length; i++) {
    const v = shown[i];
    const s = v.score;
    
    // Rank badge
    let rankClass = 'normal';
    if (i === 0) rankClass = 'gold';
    else if (i === 1) rankClass = 'silver';
    else if (i === 2) rankClass = 'bronze';
    
    // Resource chips
    let chips = '';
    for (const tIdx of v.adjacentTiles) {
      const t = tiles[tIdx];
      if (t.number > 0 && t.resource !== 'desert') {
        const prob = (PROB[t.number] * 100).toFixed(1);
        chips += `<span class="res-chip" style="background:${RESOURCE_COLORS[t.resource]};">${RESOURCE_EMOJI[t.resource]} ${t.resource} ${t.number} <span style="opacity:0.7;font-size:0.9em;">(${prob}%)</span></span>`;
      }
    }
    
    // Stats line
    let stats = `<span>‚öñÔ∏è ${s.weightedPips} wpips</span><span>üé≤ ${s.diversity} types</span>`;
    if (s.spreadBonus > 0) stats += `<span>üéØ +${s.spreadBonus} spread</span>`;
    if (s.portBonus > 0) stats += `<span>üö¢ +${s.portBonus} port</span>`;
    if (s.robberPenalty > 0) stats += `<span>üè¥‚Äç‚ò†Ô∏è ‚àí${s.robberPenalty}</span>`;
    if (s.expansionScore > 0) stats += `<span>üõ§Ô∏è +${s.expansionScore} expand</span>`;
    
    const portText = v.portAccess ? ` ¬∑ ${v.portAccess.ratio} ${v.portAccess.resource || 'any'}` : '';
    
    html += `<div class="top-card">
      <div class="top-rank ${rankClass}">${i + 1}</div>
      <div class="top-score">${s.totalScore}<small>pts</small></div>
      <div class="top-detail">
        <div class="top-resources">${chips}</div>
        <div class="top-stats">${stats}</div>
      </div>
    </div>`;
  }
  el.innerHTML = html;
}

// #8: Settlement planning panel
function updateSettlePanel() {
  const panel = document.getElementById('settlePanel');
  const picksEl = document.getElementById('settlePicks');
  const combinedEl = document.getElementById('settleCombined');
  
  if (!settleMode) {
    panel.classList.remove('visible');
    return;
  }
  panel.classList.add('visible');
  
  // Find optimal pairs when entering settle mode
  findOptimalPairs();
  
  let html = '';
  
  // Show optimal pairs section
  html += `<div style="margin-bottom: 16px;">
    <h4 style="font-size:0.88em;font-weight:600;color:#10b981;margin-bottom:8px;">üèÜ Top 10 Optimal Settlement Pairs</h4>
    <div id="optimalPairsList" style="max-height:200px;overflow-y:auto;border:1px solid rgba(255,255,255,0.06);border-radius:8px;background:rgba(255,255,255,0.02);">`;
  
  for (let i = 0; i < optimalPairs.length; i++) {
    const pair = optimalPairs[i];
    const resources = [...pair.combinedResources].map(r => RESOURCE_EMOJI[r]).join('');
    
    let rankBadge = '';
    if (i === 0) rankBadge = 'ü•á';
    else if (i === 1) rankBadge = 'ü•à';
    else if (i === 2) rankBadge = 'ü•â';
    else rankBadge = `${i + 1}.`;
    
    const isSelected = selectedPair === pair;
    const bgColor = isSelected ? 'rgba(16,185,129,0.15)' : 'rgba(255,255,255,0.03)';
    const borderColor = isSelected ? 'rgba(16,185,129,0.3)' : 'rgba(255,255,255,0.06)';
    
    html += `<div style="display:flex;align-items:center;gap:8px;padding:6px 10px;border-bottom:1px solid rgba(255,255,255,0.04);background:${bgColor};border-left:2px solid ${borderColor};cursor:pointer;" onclick="selectPair(${i})">
      <span style="font-weight:700;min-width:25px;color:#10b981;">${rankBadge}</span>
      <span style="font-weight:700;color:#e6a817;min-width:35px;">${pair.totalScore}</span>
      <span style="font-size:0.78em;color:#cbd5e1;flex:1;">
        ${pair.resourceCount}/5 resources (${resources}) ¬∑ ${pair.numberCount} numbers
      </span>
      <button onclick="event.stopPropagation(); highlightPair(${i})" style="padding:3px 8px;font-size:0.7em;background:rgba(16,185,129,0.2);color:#10b981;border:1px solid rgba(16,185,129,0.3);border-radius:4px;cursor:pointer;">Show</button>
    </div>`;
  }
  
  html += `</div></div>`;
  
  // Show manual selection section
  html += `<div style="margin-bottom: 12px;">
    <h4 style="font-size:0.88em;font-weight:600;color:#94a3b8;margin-bottom:8px;">üéØ Manual Selection</h4>
    <p style="font-size:0.78em;color:#64748b;margin-bottom:8px;">Or click vertices on the board to pick a custom pair</p>
  </div>`;
  
  // Show current selection
  if (selectedPair) {
    html += `<div style="padding:10px 12px;border-radius:8px;background:rgba(16,185,129,0.08);border:1px solid rgba(16,185,129,0.15);margin-bottom:12px;">
      <h4 style="font-size:0.85em;font-weight:600;color:#10b981;margin-bottom:6px;">‚úì Selected Pair</h4>
      <div style="font-size:0.78em;color:#a7f3d0;">
        Score: ${selectedPair.totalScore} ¬∑ Resources: ${[...selectedPair.combinedResources].map(r => `${RESOURCE_EMOJI[r]} ${r}`).join(', ')}
      </div>
    </div>`;
  } else if (pickedSettlements.length > 0) {
    html += '<div style="margin-bottom: 12px;">';
    for (let i = 0; i < pickedSettlements.length; i++) {
      const v = pickedSettlements[i];
      const s = v.score || scoreVertex(v);
      if (!s) continue;
      
      let resChips = '';
      for (const tIdx of v.adjacentTiles) {
        const t = tiles[tIdx];
        if (t.number > 0 && t.resource !== 'desert') {
          resChips += `<span class="res-chip" style="background:${RESOURCE_COLORS[t.resource]};font-size:0.72em;margin:1px;">${RESOURCE_EMOJI[t.resource]} ${t.resource} ${t.number}</span>`;
        }
      }
      
      html += `<div style="padding:8px 10px;border-radius:6px;background:rgba(255,255,255,0.03);border:1px solid rgba(255,255,255,0.06);margin-bottom:6px;">
        <h4 style="font-size:0.8em;font-weight:600;color:#94a3b8;margin-bottom:4px;">${i === 0 ? '1st' : '2nd'} Settlement (Score: ${s.totalScore})</h4>
        <div style="display:flex;gap:3px;flex-wrap:wrap;">${resChips}</div>
      </div>`;
    }
    html += '</div>';
    
    if (pickedSettlements.length === 2) {
      // Auto-select this pair for resource engine
      selectedPair = { v1: pickedSettlements[0], v2: pickedSettlements[1] };
      const pairScore = scorePair(pickedSettlements[0], pickedSettlements[1]);
      if (pairScore) {
        selectedPair = pairScore;
      }
    }
  }
  
  picksEl.innerHTML = html;
  
  // Show resource engine if pair is selected
  updateResourceEngine();
  
  combinedEl.style.display = 'none'; // Hide old combined display
}

// Make these functions global for HTML onclick handlers
window.selectPair = function(index) {
  selectedPair = optimalPairs[index];
  pickedSettlements = [selectedPair.v1, selectedPair.v2];
  drawBoard();
}

window.highlightPair = function(index) {
  pickedSettlements = [optimalPairs[index].v1, optimalPairs[index].v2];
  selectedPair = optimalPairs[index]; // Also select it for resource engine
  drawBoard();
}

// Update resource engine analysis panel
function updateResourceEngine() {
  const engineEl = document.getElementById('resourceEngine');
  
  if (!selectedPair) {
    if (engineEl) engineEl.remove();
    return;
  }
  
  const engine = calculateResourceEngine(selectedPair.v1, selectedPair.v2);
  
  // Create resource engine panel if it doesn't exist
  if (!engineEl) {
    const panel = document.getElementById('settlePanel');
    const engineDiv = document.createElement('div');
    engineDiv.id = 'resourceEngine';
    engineDiv.style.cssText = `
      margin-top: 16px;
      padding: 14px 16px;
      border-radius: 12px;
      background: rgba(16, 185, 129, 0.08);
      border: 1px solid rgba(16, 185, 129, 0.15);
    `;
    panel.appendChild(engineDiv);
  }
  
  const el = document.getElementById('resourceEngine');
  
  let html = `<h4 style="font-size:0.9em;font-weight:700;color:#10b981;margin-bottom:12px;">üîß Resource Engine Analysis</h4>`;
  
  // Resource income per 36 rolls
  html += `<div style="margin-bottom:14px;">
    <h5 style="font-size:0.82em;font-weight:600;color:#a7f3d0;margin-bottom:6px;">üìä Expected Income (per 36 rolls)</h5>
    <div style="display:grid;grid-template-columns:repeat(5,1fr);gap:6px;font-size:0.75em;">`;
  
  for (const resource of ['brick', 'ore', 'wood', 'wheat', 'sheep']) {
    const income = (engine.resourceIncome[resource] * 36).toFixed(1);
    const prob = (engine.resourceIncome[resource] * 100).toFixed(1);
    html += `<div style="text-align:center;padding:4px;border-radius:4px;background:rgba(255,255,255,0.05);">
      <div style="font-size:0.7em;color:#94a3b8;">${RESOURCE_EMOJI[resource]}</div>
      <div style="font-weight:600;color:#e2e8f0;">${income}</div>
      <div style="font-size:0.65em;color:#64748b;">${prob}%</div>
    </div>`;
  }
  
  html += `</div></div>`;
  
  // Building affordability
  html += `<div>
    <h5 style="font-size:0.82em;font-weight:600;color:#a7f3d0;margin-bottom:8px;">üèóÔ∏è Building Affordability</h5>`;
  
  const buildings = {
    road: { icon: 'üõ§Ô∏è', name: 'Road', desc: 'Brick + Wood' },
    settlement: { icon: 'üè†', name: 'Settlement', desc: 'Brick + Wood + Wheat + Sheep' },
    city: { icon: 'üèôÔ∏è', name: 'City', desc: '3 Ore + 2 Wheat' },
    devCard: { icon: 'üÉè', name: 'Dev Card', desc: 'Ore + Wheat + Sheep' }
  };
  
  for (const [key, info] of Object.entries(buildings)) {
    const afford = engine.affordability[key];
    
    let display, color, bgColor;
    if (key === 'city') {
      if (afford === Infinity) {
        display = 'Never';
        color = '#ef4444';
        bgColor = 'rgba(239, 68, 68, 0.1)';
      } else if (afford <= 3) {
        display = `~${afford.toFixed(1)} turns`;
        color = '#22c55e';
        bgColor = 'rgba(34, 197, 94, 0.1)';
      } else if (afford <= 6) {
        display = `~${afford.toFixed(1)} turns`;
        color = '#f59e0b';
        bgColor = 'rgba(245, 158, 11, 0.1)';
      } else {
        display = `~${afford.toFixed(1)} turns`;
        color = '#ef4444';
        bgColor = 'rgba(239, 68, 68, 0.1)';
      }
    } else {
      if (afford === 0) {
        display = 'Never';
        color = '#ef4444';
        bgColor = 'rgba(239, 68, 68, 0.1)';
      } else if (afford >= 0.7) {
        display = `${(afford * 100).toFixed(0)}% per turn`;
        color = '#22c55e';
        bgColor = 'rgba(34, 197, 94, 0.1)';
      } else if (afford >= 0.3) {
        display = `${(afford * 100).toFixed(0)}% per turn`;
        color = '#f59e0b';
        bgColor = 'rgba(245, 158, 11, 0.1)';
      } else {
        display = `${(afford * 100).toFixed(0)}% per turn`;
        color = '#ef4444';
        bgColor = 'rgba(239, 68, 68, 0.1)';
      }
    }
    
    html += `<div style="display:flex;align-items:center;justify-content:space-between;padding:6px 10px;margin:3px 0;border-radius:6px;background:${bgColor};">
      <div style="display:flex;align-items:center;gap:8px;flex:1;">
        <span style="font-size:1em;">${info.icon}</span>
        <div>
          <div style="font-size:0.8em;font-weight:600;color:#e2e8f0;">${info.name}</div>
          <div style="font-size:0.7em;color:#94a3b8;">${info.desc}</div>
        </div>
      </div>
      <div style="font-size:0.75em;font-weight:600;color:${color};">${display}</div>
    </div>`;
  }
  
  html += `</div>`;
  
  el.innerHTML = html;
}

// === #7: Share Board State ===
function encodeBoardState() {
  // Compact: mode + resource initial + number for each tile
  // Format: mode|r1n1,r2n2,...  (r=resource first char, n=number)
  const resMap = { brick:'b', ore:'o', wood:'w', wheat:'h', sheep:'s', desert:'d' };
  const parts = tiles.map(t => resMap[t.resource] + t.number);
  return currentMode + '|' + parts.join(',');
}

function decodeBoardState(str) {
  const revMap = { b:'brick', o:'ore', w:'wood', h:'wheat', s:'sheep', d:'desert' };
  const [mode, data] = str.split('|');
  if (!data) return null;
  const parts = data.split(',');
  return { mode, tiles: parts.map(p => ({ resource: revMap[p[0]] || 'desert', number: parseInt(p.slice(1)) || 0 })) };
}

function shareBoard() {
  const state = encodeBoardState();
  const encoded = btoa(state);
  const url = window.location.origin + window.location.pathname + '?b=' + encoded;
  navigator.clipboard.writeText(url).then(() => {
    showToast('üîó Board link copied to clipboard!');
  }).catch(() => {
    // Fallback
    const ta = document.createElement('textarea');
    ta.value = url;
    document.body.appendChild(ta);
    ta.select();
    document.execCommand('copy');
    document.body.removeChild(ta);
    showToast('üîó Board link copied!');
  });
}

function loadFromURL() {
  const params = new URLSearchParams(window.location.search);
  const b = params.get('b');
  if (!b) return false;
  try {
    const decoded = atob(b);
    const state = decodeBoardState(decoded);
    if (!state) return false;
    switchMode(state.mode);
    const count = Math.min(state.tiles.length, tiles.length);
    for (let i = 0; i < count; i++) {
      tiles[i].resource = state.tiles[i].resource;
      tiles[i].number = state.tiles[i].number;
    }
    return true;
  } catch(e) { return false; }
}

function showToast(msg) {
  const existing = document.querySelector('.toast');
  if (existing) existing.remove();
  const el = document.createElement('div');
  el.className = 'toast';
  el.textContent = msg;
  document.body.appendChild(el);
  setTimeout(() => el.remove(), 2000);
}

// Click handling
canvas.addEventListener('click', (e) => {
  const rect = canvas.getBoundingClientRect();
  const mx = (e.clientX - rect.left) * (canvas.width / rect.width);
  const my = (e.clientY - rect.top) * (canvas.height / rect.height);
  
  // #8: In settle mode, clicking picks a vertex
  if (settleMode) {
    let closestV = null, minDist = Infinity;
    for (const v of vertices) {
      if (!v.isLand || !v.score) continue;
      const d = Math.hypot(mx - v.x, my - v.y);
      if (d < 20 && d < minDist) { closestV = v; minDist = d; }
    }
    if (closestV && pickedSettlements.length < 2 && !pickedSettlements.includes(closestV)) {
      // Check if this would make a valid pair
      if (pickedSettlements.length === 1) {
        if (!isValidSettlementPair(pickedSettlements[0], closestV)) {
          showToast('‚ö†Ô∏è Settlements must not be adjacent!');
          return;
        }
      }
      pickedSettlements.push(closestV);
      
      // If we now have a pair, set it as selected
      if (pickedSettlements.length === 2) {
        const pairScore = scorePair(pickedSettlements[0], pickedSettlements[1]);
        selectedPair = pairScore || { v1: pickedSettlements[0], v2: pickedSettlements[1] };
      } else {
        selectedPair = null;
      }
      
      drawBoard();
      return;
    } else if (closestV && pickedSettlements.includes(closestV)) {
      // Clicking already selected vertex deselects it
      pickedSettlements = pickedSettlements.filter(v => v !== closestV);
      selectedPair = null;
      const engineEl = document.getElementById('resourceEngine');
      if (engineEl) engineEl.remove();
      drawBoard();
      return;
    }
  }
  
  let closest = null, minDist = Infinity;
  for (const tile of tiles) {
    const d = Math.hypot(mx - tile.cx, my - tile.cy);
    if (d < HEX_R && d < minDist) { closest = tile; minDist = d; }
  }
  if (closest) {
    const num = parseInt(document.getElementById('numberSelect').value);
    closest.number = num;
    if (num === 0) closest.resource = 'desert';
    else if (closest.resource === 'desert') {
      closest.resource = RESOURCE_NAMES[Math.floor(Math.random() * RESOURCE_NAMES.length)];
    }
    drawBoard();
  }
});

// Tooltip
canvas.addEventListener('mousemove', (e) => {
  const rect = canvas.getBoundingClientRect();
  const mx = (e.clientX - rect.left) * (canvas.width / rect.width);
  const my = (e.clientY - rect.top) * (canvas.height / rect.height);
  let closest = null, minDist = Infinity;
  for (const v of vertices) {
    if (v.dots === 0 || !v.isLand) continue;
    const d = Math.hypot(mx - v.x, my - v.y);
    if (d < 15 && d < minDist) { closest = v; minDist = d; }
  }
  if (closest && closest.score) {
    const s = closest.score;
    const lines = [`<b>Score: ${s.totalScore}</b>`];
    lines.push(`<b>${s.rawPips} pips</b> (weighted: ${s.weightedPips})`);
    for (const tIdx of closest.adjacentTiles) {
      const t = tiles[tIdx];
      if (t.number > 0) {
        const prob = (PROB[t.number] * 100).toFixed(1);
        lines.push(`${RESOURCE_EMOJI[t.resource]} ${t.resource} ${t.number} ‚Äî ${prob}% per roll`);
      }
    }
    lines.push(`Diversity: ${s.diversity} type${s.diversity !== 1 ? 's' : ''} (+${s.diversityBonus})`);
    if (s.spreadBonus > 0) lines.push(`Number spread: +${s.spreadBonus}`);
    if (s.portBonus > 0) lines.push(`Port: ${closest.portAccess.ratio} ${closest.portAccess.resource || 'any'} (+${s.portBonus})`);
    if (s.robberPenalty > 0) lines.push(`Robber risk: -${s.robberPenalty}`);
    if (s.expansionScore > 0) lines.push(`Expansion: +${s.expansionScore}`);
    if (settleMode && pickedSettlements.includes(closest)) {
      lines.push(`<b style="color:#10b981;">‚úì Selected settlement</b>`);
    }
    tooltip.innerHTML = lines.join('<br>');
    tooltip.style.display = 'block';
    tooltip.style.left = (e.clientX - rect.left + 15) + 'px';
    tooltip.style.top = (e.clientY - rect.top - 10) + 'px';
  } else {
    tooltip.style.display = 'none';
  }
});
canvas.addEventListener('mouseleave', () => { tooltip.style.display = 'none'; });

// Event listeners
document.getElementById('mode4p').addEventListener('click', () => switchMode('4p'));
document.getElementById('mode6p').addEventListener('click', () => switchMode('6p'));
document.getElementById('randomBtn').addEventListener('click', () => {
  pickedSettlements = [];
  randomizeBoard();
  drawBoard();
});
document.getElementById('clearBtn').addEventListener('click', () => {
  pickedSettlements = [];
  for (const t of tiles) { t.number = 0; t.resource = 'desert'; }
  drawBoard();
});
document.getElementById('topN').addEventListener('change', drawBoard);

let showAllScores = false;
document.getElementById('showAllBtn').addEventListener('click', () => {
  showAllScores = !showAllScores;
  document.getElementById('showAllBtn').classList.toggle('active', showAllScores);
  document.getElementById('showAllBtn').textContent = showAllScores ? 'üìä Top Only' : 'üìä All Scores';
  drawBoard();
});

// #7: Share button
document.getElementById('shareBtn').addEventListener('click', shareBoard);

// #8: Settlement planning toggle
document.getElementById('settleBtn').addEventListener('click', () => {
  settleMode = !settleMode;
  pickedSettlements = [];
  selectedPair = null;
  optimalPairs = [];
  document.getElementById('settleBtn').classList.toggle('active', settleMode);
  document.getElementById('settleBtn').textContent = settleMode ? 'üèòÔ∏è Exit Planner' : 'üèòÔ∏è Plan Settlements';
  
  // Clean up resource engine panel
  const engineEl = document.getElementById('resourceEngine');
  if (engineEl) engineEl.remove();
  
  drawBoard();
});
document.getElementById('resetPicksBtn').addEventListener('click', () => {
  pickedSettlements = [];
  selectedPair = null;
  const engineEl = document.getElementById('resourceEngine');
  if (engineEl) engineEl.remove();
  drawBoard();
});

// --- Photo Scan Feature ---
const scanBtn = document.getElementById('scanBtn');
const photoInput = document.getElementById('photoInput');

function getApiKey() {
  let key = localStorage.getItem('openai_api_key');
  if (key) return key;
  key = prompt('Enter your OpenAI API key to use board scanning.\nIt\'s stored locally in your browser only.\n\nGet one at platform.openai.com/api-keys');
  if (key && key.startsWith('sk-')) {
    localStorage.setItem('openai_api_key', key);
    return key;
  }
  return null;
}

scanBtn.addEventListener('click', () => {
  const key = getApiKey();
  if (!key) return;
  photoInput.click();
});

photoInput.addEventListener('change', async (e) => {
  const file = e.target.files[0];
  if (!file) return;
  const key = localStorage.getItem('openai_api_key');
  if (!key) return;
  scanBtn.textContent = '‚è≥ Analyzing...';
  scanBtn.disabled = true;
  try {
    const base64 = await new Promise((resolve) => {
      const reader = new FileReader();
      reader.onload = () => resolve(reader.result.split(',')[1]);
      reader.readAsDataURL(file);
    });
    const response = await fetch('https://api.openai.com/v1/chat/completions', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${key}` },
      body: JSON.stringify({
        model: 'gpt-4o',
        max_tokens: 1500,
        messages: [{
          role: 'user',
          content: [
            { type: 'text', text: `Analyze this photo of a Catan board. The board has hex tiles arranged in rows of [3,4,5,6,5,4,3] (30 tiles total for 6-player, or [3,4,5,4,3] = 19 tiles for standard).

For each tile, identify:
1. The resource type: brick (red/brown hills), ore (grey mountains), wood (dark green forest), wheat (yellow fields), sheep (light green pastures), or desert (tan/sandy, no number)
2. The number token on it (2-12, or 0 for desert)

Return ONLY a JSON array of objects, one per tile, in row-by-row order (top row left-to-right, then next row, etc.):
[{"resource":"wheat","number":5},{"resource":"ore","number":8},...]

If you can't identify a tile clearly, use your best guess. Desert tiles have number 0.` },
            { type: 'image_url', image_url: { url: `data:image/jpeg;base64,${base64}` } }
          ]
        }]
      })
    });
    const data = await response.json();
    if (data.error) {
      if (data.error.code === 'invalid_api_key') {
        localStorage.removeItem('openai_api_key');
        alert('Invalid API key. It has been cleared ‚Äî try again.');
      } else {
        alert('API error: ' + data.error.message);
      }
      return;
    }
    const content = data.choices[0].message.content;
    const jsonMatch = content.match(/\[[\s\S]*\]/);
    if (!jsonMatch) {
      alert('Could not parse board from image. Try a clearer photo.');
      return;
    }
    const parsed = JSON.parse(jsonMatch[0]);
    if (parsed.length === 19) {
      switchMode('4p');
    } else if (parsed.length >= 28 && parsed.length <= 30) {
      switchMode('6p');
    }
    const count = Math.min(parsed.length, tiles.length);
    for (let i = 0; i < count; i++) {
      const p = parsed[i];
      tiles[i].resource = p.resource || 'desert';
      tiles[i].number = parseInt(p.number) || 0;
      if (tiles[i].number === 0) tiles[i].resource = 'desert';
    }
    drawBoard();
    showToast(`‚úÖ Board scanned! ${count} tiles detected.`);
  } catch (err) {
    console.error(err);
    alert('Failed to analyze image: ' + err.message);
  } finally {
    scanBtn.textContent = 'üì∑ Scan Board';
    scanBtn.disabled = false;
    photoInput.value = '';
  }
});

// Init
resizeCanvas();
buildBoard();
// #7: Try loading from URL first
if (!loadFromURL()) {
  randomizeBoard();
}
drawBoard();
</script>
</body>
</html>