<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Catan 6P Settlement Optimizer</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #1a1a2e; color: #eee; font-family: 'Segoe UI', sans-serif; display: flex; flex-direction: column; align-items: center; min-height: 100vh; padding: 20px; }
h1 { margin-bottom: 4px; font-size: 1.6em; color: #e6a817; }
.subtitle { color: #888; margin-bottom: 16px; font-size: 0.9em; }
.controls { display: flex; gap: 12px; margin-bottom: 16px; flex-wrap: wrap; justify-content: center; align-items: center; }
button { background: #e6a817; color: #1a1a2e; border: none; padding: 8px 18px; border-radius: 6px; cursor: pointer; font-weight: 600; font-size: 0.9em; }
button:hover { background: #f0c040; }
button.secondary { background: #333; color: #ccc; }
button.secondary:hover { background: #444; }
select { background: #333; color: #eee; border: 1px solid #555; padding: 6px 10px; border-radius: 6px; font-size: 0.9em; }
canvas { border-radius: 12px; background: #0f3460; cursor: pointer; }
.legend { display: flex; gap: 16px; margin-top: 14px; flex-wrap: wrap; justify-content: center; font-size: 0.85em; }
.legend-item { display: flex; align-items: center; gap: 5px; }
.legend-dot { width: 14px; height: 14px; border-radius: 50%; }
.info { max-width: 700px; margin-top: 16px; background: #16213e; padding: 14px 18px; border-radius: 8px; font-size: 0.85em; line-height: 1.5; color: #aaa; }
.top-list { margin-top: 12px; background: #16213e; padding: 14px 18px; border-radius: 8px; font-size: 0.85em; max-width: 700px; width: 100%; }
.top-list h3 { color: #e6a817; margin-bottom: 8px; }
.top-list ol { padding-left: 20px; }
.top-list li { margin-bottom: 3px; color: #ccc; }
.top-list li span.dots { color: #e6a817; font-weight: 700; }
.top-list li span.res { color: #888; font-size: 0.9em; }
#tooltip { position: absolute; background: rgba(0,0,0,0.85); color: #fff; padding: 8px 12px; border-radius: 6px; font-size: 0.82em; pointer-events: none; display: none; z-index: 10; line-height: 1.4; }
</style>
</head>
<body>
<h1>üè† Catan 6P Settlement Optimizer</h1>
<p class="subtitle">Click tiles to assign numbers, then see the best settlement spots</p>
<div class="controls">
  <label>Assign: <select id="numberSelect">
    <option value="0">Desert</option>
    <option value="2">2</option><option value="3">3</option><option value="4">4</option><option value="5">5</option>
    <option value="6">6</option><option value="8">8</option><option value="9">9</option>
    <option value="10">10</option><option value="11">11</option><option value="12">12</option>
  </select></label>
  <button id="randomBtn">üé≤ Random Board</button>
  <button id="clearBtn" class="secondary">Clear</button>
  <label>Show top: <select id="topN"><option value="5">5</option><option value="10" selected>10</option><option value="15">15</option><option value="20">20</option></select></label>
</div>
<div style="position:relative; display:inline-block;">
  <canvas id="board" width="820" height="760"></canvas>
  <div id="tooltip"></div>
</div>
<div class="legend">
  <div class="legend-item"><div class="legend-dot" style="background:#00ff88;"></div> Best (top tier)</div>
  <div class="legend-item"><div class="legend-dot" style="background:#ffdd00;"></div> Great</div>
  <div class="legend-item"><div class="legend-dot" style="background:#ff8800;"></div> Good</div>
  <div class="legend-item"><div class="legend-dot" style="background:#ff3355;"></div> Weak</div>
  <div class="legend-item"><div class="legend-dot" style="background:#666;"></div> No value</div>
</div>
<div class="top-list" id="topList"></div>
<div class="info">
  <b>How it works:</b> Each number token has a probability of being rolled (dots on the token). 
  A settlement vertex touches up to 3 tiles. The optimizer sums the probabilities of all adjacent tiles 
  for every vertex and ranks them. Resource diversity is shown but not weighted ‚Äî you decide what matters. 
  Click a tile to assign a number, or hit Random for a valid 6-player layout.
</div>

<script>
// --- Catan 6-player board geometry ---
// 6-player board: rows of 3,4,5,6,5,6,5,4,3 tiles (but actually it's 3,4,5,6,5,6,5,4,3 ‚Äî wait)
// Standard 6-player extension: rows 4,5,6,5,6,5,4  ‚Äî nope
// Actually: 6-player Catan has 30 land tiles. Layout rows: 3,4,5,6,5,4,3
const ROWS = [3,4,5,6,5,4,3];
const TOTAL_TILES = 30;

const RESOURCE_COLORS = {
  brick: '#c0392b', ore: '#7f8c8d', wood: '#27ae60', wheat: '#f1c40f', sheep: '#2ecc71', desert: '#c2b280'
};
const RESOURCE_NAMES = ['brick','ore','wood','wheat','sheep'];

// Probability dots for each number
const DOTS = {0:0, 2:1, 3:2, 4:3, 5:4, 6:5, 8:5, 9:4, 10:3, 11:2, 12:1};

// 6-player token distribution: 2x(2,12), 3x(3,4,5,9,10,11), 4x(6,8), 2 deserts
const SIX_P_TOKENS = [0,0, 2,2, 3,3,3, 4,4,4, 5,5,5, 6,6,6,6, 8,8,8,8, 9,9,9, 10,10,10, 11,11,11, 12,12];
// That's 2+2+3+3+3+4+4+3+3+3+2 = 32... let me just use the correct distribution
// Standard 6P: 2 deserts, tokens: 2,3,3,4,4,5,5,6,6,8,8,9,9,10,10,11,11,12 (base) + extension adds more
// Easier: just use 30 tiles, shuffle numbers randomly with correct distribution

const SIX_PLAYER_NUMBERS = [
  0, 0,  // 2 deserts
  2, 2,  // 2x2
  12, 12, // 2x12
  3, 3, 3, // 3x3
  4, 4, 4,
  5, 5, 5,
  6, 6, 6,
  8, 8, 8,
  9, 9, 9,
  10, 10, 10,
  11, 11, 11
]; // = 2+2+2+3+3+3+3+3+3+3 = 27... need 30
// Let me just do 30 properly
// Base game: 19 tiles (1 desert, 18 numbered). Extension adds 11 tiles (1 desert, 2 each of some, etc.)
// I'll just let the random generator pick valid distributions for 30 tiles.

function generateRandomNumbers() {
  // 6-player: 30 tiles, 2 deserts, 28 numbered
  // Distribution: 2√ó{2,12}, 3√ó{3,4,5,9,10,11}, 4√ó{6,8} = 2+2+3+3+3+3+3+3+4+4 = 30-2 = 28 ‚úì
  const nums = [
    0, 0,
    2, 2,
    3, 3, 3,
    4, 4, 4,
    5, 5, 5,
    6, 6, 6, 6,
    8, 8, 8, 8,
    9, 9, 9,
    10, 10, 10,
    11, 11, 11,
    12, 12
  ]; // = 30 ‚úì
  // Shuffle
  for (let i = nums.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [nums[i], nums[j]] = [nums[j], nums[i]];
  }
  return nums;
}

function generateRandomResources() {
  // 6P: 30 tiles. 2 desert, rest: brick 5, ore 5, wood 6, wheat 6, sheep 6
  const res = [
    ...Array(2).fill('desert'),
    ...Array(5).fill('brick'),
    ...Array(5).fill('ore'),
    ...Array(6).fill('wood'),
    ...Array(6).fill('wheat'),
    ...Array(6).fill('sheep')
  ];
  for (let i = res.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [res[i], res[j]] = [res[j], res[i]];
  }
  return res;
}

// State
let tiles = []; // {cx, cy, number, resource, row, col}
let vertices = []; // {x, y, adjacentTiles: [idx...], dots, resources}

const canvas = document.getElementById('board');
const ctx = canvas.getContext('2d');
const tooltip = document.getElementById('tooltip');

const HEX_R = 46; // radius
const HEX_H = HEX_R * Math.sqrt(3);
const CX = canvas.width / 2;
const CY = canvas.height / 2;

function hexCorner(cx, cy, r, i) {
  const angle = Math.PI / 180 * (60 * i - 30);
  return { x: cx + r * Math.cos(angle), y: cy + r * Math.sin(angle) };
}

function buildBoard() {
  tiles = [];
  const rowOffsets = [];
  const totalRows = ROWS.length;
  const startY = CY - ((totalRows - 1) / 2) * HEX_H;
  
  let idx = 0;
  for (let r = 0; r < ROWS.length; r++) {
    const count = ROWS[r];
    const y = startY + r * HEX_H;
    const startX = CX - ((count - 1) / 2) * (HEX_R * 1.5 + HEX_R * 0.5);
    // Horizontal spacing: 1.5 * R between centers
    const spacing = HEX_R * 3;
    const rowStartX = CX - ((count - 1) / 2) * (HEX_R * 1.5);
    for (let c = 0; c < count; c++) {
      const x = rowStartX + c * HEX_R * 1.5;
      // Wait, hex grid spacing: horizontal = 1.5*R (pointy-top) but we use flat-top
      // For flat-top hex: horiz spacing = sqrt(3)*R, vert spacing = 1.5*R
      // Let me redo with flat-top hexes
    }
  }
  
  // Redo with flat-top hexes
  tiles = [];
  // flat-top hex: width = 2*R, height = sqrt(3)*R
  // horiz spacing between centers in same row: 2*R * 3/4 * 2 = 3*R ... no
  // flat-top: col spacing = 1.5*R*2? No.
  // Let's use pointy-top. height = 2*R, width = sqrt(3)*R
  // Row spacing (vertical): 1.5 * R... no
  // Pointy-top: 
  //   width = sqrt(3) * R
  //   height = 2 * R
  //   horizontal distance between adjacent hexes in same row = sqrt(3) * R
  //   vertical distance between rows = 1.5 * R
  //   odd rows offset by sqrt(3)/2 * R
  
  // But Catan board is arranged in expanding/contracting rows, not offset grid.
  // Easier: just compute hex centers for the specific row structure.
  
  // Using pointy-top hexagons:
  const hSpacing = Math.sqrt(3) * HEX_R; // horizontal distance between hex centers in same row
  const vSpacing = 1.5 * HEX_R; // vertical distance between rows
  
  // But Catan rows alternate offset. In a Catan hex grid with rows [3,4,5,6,5,4,3]:
  // Each row is centered, and consecutive rows are offset by hSpacing/2
  
  const totalHeight = (ROWS.length - 1) * vSpacing;
  const topY = CY - totalHeight / 2;
  
  let tileIdx = 0;
  for (let r = 0; r < ROWS.length; r++) {
    const count = ROWS[r];
    const y = topY + r * vSpacing;
    const rowWidth = (count - 1) * hSpacing;
    const startX = CX - rowWidth / 2;
    for (let c = 0; c < count; c++) {
      tiles.push({
        cx: startX + c * hSpacing,
        cy: y,
        number: 0,
        resource: 'desert',
        row: r,
        col: c,
        idx: tileIdx++
      });
    }
  }
  
  // Build vertices (each hex has 6 corners; merge shared corners)
  buildVertices();
}

function buildVertices() {
  vertices = [];
  const vMap = new Map(); // key "x,y" -> vertex index
  const SNAP = 3; // snap distance
  
  function snapKey(x, y) {
    // Round to nearest snap grid
    const sx = Math.round(x / SNAP) * SNAP;
    const sy = Math.round(y / SNAP) * SNAP;
    return `${sx},${sy}`;
  }
  
  for (let t = 0; t < tiles.length; t++) {
    const tile = tiles[t];
    for (let i = 0; i < 6; i++) {
      const corner = hexCorner(tile.cx, tile.cy, HEX_R, i);
      const key = snapKey(corner.x, corner.y);
      if (!vMap.has(key)) {
        const vIdx = vertices.length;
        vertices.push({ x: corner.x, y: corner.y, adjacentTiles: [t], key });
        vMap.set(key, vIdx);
      } else {
        const vIdx = vMap.get(key);
        if (!vertices[vIdx].adjacentTiles.includes(t)) {
          vertices[vIdx].adjacentTiles.push(t);
        }
      }
    }
  }
}

function computeVertexValues() {
  for (const v of vertices) {
    let totalDots = 0;
    const resources = new Set();
    for (const tIdx of v.adjacentTiles) {
      const t = tiles[tIdx];
      totalDots += DOTS[t.number] || 0;
      if (t.resource !== 'desert' && t.number > 0) resources.add(t.resource);
    }
    v.dots = totalDots;
    v.resources = resources;
  }
}

function randomizeBoard() {
  const numbers = generateRandomNumbers();
  const resources = generateRandomResources();
  // Ensure deserts get 0
  // First, assign resources, then assign numbers. Desert tiles get 0.
  for (let i = 0; i < tiles.length; i++) {
    tiles[i].resource = resources[i];
    tiles[i].number = resources[i] === 'desert' ? 0 : 0; // will assign below
  }
  // Assign numbered tokens to non-desert tiles
  const numberedTokens = numbers.filter(n => n > 0);
  // Shuffle numbered tokens
  let ni = 0;
  for (let i = 0; i < tiles.length; i++) {
    if (tiles[i].resource === 'desert') {
      tiles[i].number = 0;
    } else {
      tiles[i].number = numberedTokens[ni++] || 0;
    }
  }
}

function drawBoard() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  
  // Draw water background
  ctx.fillStyle = '#0f3460';
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  
  // Draw tiles
  for (const tile of tiles) {
    drawHex(tile);
  }
  
  // Compute vertex values
  computeVertexValues();
  
  // Find max dots for color scaling
  const maxDots = Math.max(...vertices.map(v => v.dots), 1);
  
  // Get sorted vertices for top-N
  const sorted = [...vertices].filter(v => v.dots > 0).sort((a, b) => b.dots - a.dots);
  const topN = parseInt(document.getElementById('topN').value);
  const topSet = new Set(sorted.slice(0, topN));
  
  // Draw vertices
  for (const v of vertices) {
    if (v.dots === 0) continue;
    const ratio = v.dots / maxDots;
    let color, radius;
    if (topSet.has(v) && sorted.indexOf(v) < Math.ceil(topN * 0.3)) {
      color = '#00ff88'; radius = 10;
    } else if (topSet.has(v) && sorted.indexOf(v) < Math.ceil(topN * 0.6)) {
      color = '#ffdd00'; radius = 9;
    } else if (topSet.has(v)) {
      color = '#ff8800'; radius = 8;
    } else {
      color = `rgba(255,255,255,${0.15 + ratio * 0.35})`;
      radius = 4 + ratio * 3;
    }
    
    ctx.beginPath();
    ctx.arc(v.x, v.y, radius, 0, Math.PI * 2);
    ctx.fillStyle = color;
    ctx.fill();
    
    if (topSet.has(v)) {
      ctx.strokeStyle = 'white';
      ctx.lineWidth = 1.5;
      ctx.stroke();
      
      // Draw dots number
      ctx.fillStyle = '#000';
      ctx.font = 'bold 10px sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(v.dots, v.x, v.y);
    }
  }
  
  // Update top list
  updateTopList(sorted, topN);
}

function drawHex(tile) {
  const corners = [];
  for (let i = 0; i < 6; i++) corners.push(hexCorner(tile.cx, tile.cy, HEX_R - 2, i));
  
  ctx.beginPath();
  ctx.moveTo(corners[0].x, corners[0].y);
  for (let i = 1; i < 6; i++) ctx.lineTo(corners[i].x, corners[i].y);
  ctx.closePath();
  
  ctx.fillStyle = RESOURCE_COLORS[tile.resource] || '#555';
  ctx.fill();
  ctx.strokeStyle = '#111';
  ctx.lineWidth = 2;
  ctx.stroke();
  
  // Number token
  if (tile.number > 0) {
    ctx.beginPath();
    ctx.arc(tile.cx, tile.cy, 16, 0, Math.PI * 2);
    ctx.fillStyle = '#f5f0dc';
    ctx.fill();
    ctx.strokeStyle = '#333';
    ctx.lineWidth = 1;
    ctx.stroke();
    
    ctx.fillStyle = (tile.number === 6 || tile.number === 8) ? '#cc0000' : '#222';
    ctx.font = (tile.number === 6 || tile.number === 8) ? 'bold 14px sans-serif' : '13px sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(tile.number, tile.cx, tile.cy - 1);
    
    // Dots
    const d = DOTS[tile.number];
    const dotY = tile.cy + 10;
    const dotStart = tile.cx - (d - 1) * 3;
    ctx.fillStyle = (tile.number === 6 || tile.number === 8) ? '#cc0000' : '#555';
    for (let i = 0; i < d; i++) {
      ctx.beginPath();
      ctx.arc(dotStart + i * 6, dotY, 1.5, 0, Math.PI * 2);
      ctx.fill();
    }
  }
  
  // Resource label
  ctx.fillStyle = 'rgba(255,255,255,0.7)';
  ctx.font = '9px sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText(tile.resource, tile.cx, tile.cy + (tile.number > 0 ? 22 : 5));
}

function updateTopList(sorted, topN) {
  const el = document.getElementById('topList');
  const shown = sorted.slice(0, topN);
  if (shown.length === 0) {
    el.innerHTML = '<h3>Top Settlement Spots</h3><p style="color:#666">Assign numbers to tiles first (click tiles or hit Random)</p>';
    return;
  }
  let html = `<h3>Top ${topN} Settlement Spots</h3><ol>`;
  for (const v of shown) {
    const resList = v.adjacentTiles.map(i => {
      const t = tiles[i];
      return t.number > 0 ? `${t.resource}(${t.number})` : null;
    }).filter(Boolean).join(', ');
    html += `<li><span class="dots">${v.dots} pips</span> ‚Äî <span class="res">${resList || 'none'}</span></li>`;
  }
  html += '</ol>';
  el.innerHTML = html;
}

// Click handling ‚Äî assign number to tile
canvas.addEventListener('click', (e) => {
  const rect = canvas.getBoundingClientRect();
  const mx = (e.clientX - rect.left) * (canvas.width / rect.width);
  const my = (e.clientY - rect.top) * (canvas.height / rect.height);
  
  let closest = null, minDist = Infinity;
  for (const tile of tiles) {
    const d = Math.hypot(mx - tile.cx, my - tile.cy);
    if (d < HEX_R && d < minDist) { closest = tile; minDist = d; }
  }
  if (closest) {
    const num = parseInt(document.getElementById('numberSelect').value);
    closest.number = num;
    if (num === 0) closest.resource = 'desert';
    else if (closest.resource === 'desert') {
      // Assign a random resource
      closest.resource = RESOURCE_NAMES[Math.floor(Math.random() * RESOURCE_NAMES.length)];
    }
    drawBoard();
  }
});

// Tooltip on hover
canvas.addEventListener('mousemove', (e) => {
  const rect = canvas.getBoundingClientRect();
  const mx = (e.clientX - rect.left) * (canvas.width / rect.width);
  const my = (e.clientY - rect.top) * (canvas.height / rect.height);
  
  let closest = null, minDist = Infinity;
  for (const v of vertices) {
    if (v.dots === 0) continue;
    const d = Math.hypot(mx - v.x, my - v.y);
    if (d < 15 && d < minDist) { closest = v; minDist = d; }
  }
  
  if (closest) {
    const lines = [`<b>${closest.dots} pips</b> (${(closest.dots / 36 * 100).toFixed(1)}% per roll)`];
    for (const tIdx of closest.adjacentTiles) {
      const t = tiles[tIdx];
      if (t.number > 0) lines.push(`${t.resource} ${t.number} (${DOTS[t.number]} pips)`);
    }
    lines.push(`Diversity: ${closest.resources.size} resource${closest.resources.size !== 1 ? 's' : ''}`);
    tooltip.innerHTML = lines.join('<br>');
    tooltip.style.display = 'block';
    tooltip.style.left = (e.clientX - rect.left + 15) + 'px';
    tooltip.style.top = (e.clientY - rect.top - 10) + 'px';
  } else {
    tooltip.style.display = 'none';
  }
});

canvas.addEventListener('mouseleave', () => { tooltip.style.display = 'none'; });

document.getElementById('randomBtn').addEventListener('click', () => { randomizeBoard(); drawBoard(); });
document.getElementById('clearBtn').addEventListener('click', () => {
  for (const t of tiles) { t.number = 0; t.resource = 'desert'; }
  drawBoard();
});
document.getElementById('topN').addEventListener('change', drawBoard);

// Init
buildBoard();
drawBoard();
</script>
</body>
</html>
